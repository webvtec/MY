 <!-- Sidebar -->
<div class="sidebar" id="sidebar">
    <div class="sidebar-header" id="sidebarHeader">
        <div class="sidebar-user-info" id="sidebarUserInfo">
            <div class="user-avatar" id="sidebarUserAvatar" style="background-image: none; background-size: cover; background-position: center;">?</div>
            <span id="sidebarUserName">Guest</span>
            <button class="my-profile-btn" id="myProfileBtn" onclick="goToUserDashboard()" style="display: none;">
                ðŸ‘¤ MY PROFILE
            </button>
        </div>
    </div>
    <div class="sidebar-item sidebar-item-home" onclick="navigateTo('home')">HOME</div>
    <div class="sidebar-item" onclick="navigateTo('word-database')">WORD DATABASE</div>
    <div class="sidebar-item" onclick="navigateTo('coaches')">BOOK COACHES</div>
    <div class="sidebar-item" onclick="navigateTo('students')">OUR STUDENTS</div>
    <div class="sidebar-item" onclick="()">CONTACT US</div>
    <div class="sidebar-item" onclick="navigateTo('about')">ABOUT US</div>
    <div class="sidebar-item" id="admin-nav-link" onclick="navigateTo('admin')" style="display: none;">ADMIN PANEL</div>
    <div class="sidebar-item sign-in" id="sidebar-signin" onclick="showAuthModal()">SIGN IN</div>
    <div class="sidebar-item" id="sidebar-signout" style="display:none;" onclick="signOut()">SIGN OUT</div>
</div>
</div>


    <script>
        // ===== FIREBASE CONFIGURATION =====
        const firebaseConfig = {
            apiKey: "AIzaSyCDdnDKsCUaCK4L95G57AC9-BjCqJiIywA",
            authDomain: "wordbiz-coaching-academy.firebaseapp.com",
            projectId: "wordbiz-coaching-academy",
            storageBucket: "wordbiz-coaching-academy.firebasestorage.app",
            messagingSenderId: "829294789081",
            appId: "1:829294789081:web:501ae4d3d6f3694a40d9c8"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        // ===== CLOUD FUNCTION URL =====
        const CLOUD_FUNCTION_URL = 'https://getworddefinition-998744778737.us-central1.run.app';


        
// ===== PAYPAL CONFIGURATION =====
const PAYPAL_HANDLER_URL = 'https://verificationpaypalpayment-998744778737.us-central1.run.app';
const REOPEN_ACCOUNT_COST = 6.50;
const REOPEN_DAYS = 30;

let paypalButtonRendered = false;
let sponsorPaypalRendered = false;
let currentChildData = null;

        

        let paypalSDKLoaded = false;

async function loadPayPalSDK() {
    if (paypalSDKLoaded) {
        return Promise.resolve();
    }
    
    try {
        // Get client ID from Firebase function
        const response = await fetch(`${PAYPAL_HANDLER_URL}?action=getClientId`);
        const data = await response.json();
        
        if (!data.success || !data.clientId) {
            throw new Error('Failed to get PayPal client ID');
        }
        
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = `https://www.paypal.com/sdk/js?client-id=${data.clientId}&currency=USD&locale=en_US`;
            script.async = true;
            
            script.onload = () => {
                paypalSDKLoaded = true;
                console.log('âœ… PayPal SDK loaded');
                resolve();
            };
            
            script.onerror = () => {
                reject(new Error('Failed to load PayPal SDK'));
            };
            
            document.head.appendChild(script);
        });
    } catch (error) {
        console.error('Error loading PayPal SDK:', error);
        throw error;
    }
}
        
        // ===== GLOBAL VARIABLES =====
let allWords = [];
let currentLetter = '';
let currentWord = null;
let isListening = false;
let recognition = null;
let currentUser = null;
let currentQuiz = null;
let currentQuestionIndex = 0;
let quizScore = 0;
let userFavorites = [];
let userIncorrect = [];
let userSpellingFavorites = [];
let userSpellingIncorrect = [];
let quizStartTime = null;
let quizAnswerTimes = [];
let quizDifficulty = 'medium'; // track difficulty
let questionStartTime = null;

// ===== LIVE SPELLING GLOBALS =====
let challengeListener = null;
let myChallengeListener = null;
let shownPopupIds = new Set();
let declinedChallengeIds = new Set(); // âœ… NEW: Track declined challenges
let presenceInitialized = false; // âœ… NEW: Prevent duplicate presence initialization


// ===== PARENT ID VERIFICATION VARIABLES =====
let parentIDFile = null;
let parentIDBase64 = null;
let childIDFile = null;
let childIDBase64 = null;
let parentIDVerified = false;
let childIDVerified = false;

// ===== LEVEL-BASED WORD LOADING =====
let currentLevel = '';
let levelWords = {
    foundation: [],
    challenge: [],
    advanced: [],
    championship: []
};

// Google Docs URLs for each level - REPLACE WITH YOUR ACTUAL GOOGLE DOCS IDs
const LEVEL_DOCS = {
    foundation: 'https://docs.google.com/document/d/1cgq8FfGXHfFtzeroC1BU5CpNz8Y7Y8qk7f0lduoFdz4/export?format=txt',
    challenge: 'https://docs.google.com/document/d/1sJLFvQZ2eOBOhZLEf4LhnDZCFJy8vn6sa_HV8JpK_Us/export?format=txt',
    advanced: 'https://docs.google.com/document/d/1w2lG7hLHixwn-KtNTEUgHU0txtN7_bhGIPrnvdKnPtc/export?format=txt',
    championship: 'https://docs.google.com/document/d/1ATXYyC7nQOYZ5yyDXow0v0o1efCpXLd3r0GCloCVUrY/export?format=txt'
};

// ===== SPELLING PRACTICE FUNCTIONS =====
let spellingWords = [];
let currentSpellingIndex = 0;
let spellingScore = 0;
let currentSpellingWord = '';
let spellingMistakes = [];
let selectedGameLevel = '';

// ===== UNSCRAMBLE FUNCTIONS =====
let unscrambleWords = [];
let currentUnscrambleIndex = 0;
let unscrambleScore = 0;
let currentUnscrambleWord = '';
let currentLetterOrder = [];
let hintsUsed = 0;
let draggedElement = null;

// ===== ID VERIFICATION VARIABLES =====
let uploadedIDFile = null;
let uploadedIDBase64 = null;
let isCoachVerification = false;
let idVerificationPassed = false;

// ===== LIVE SPELLING VARIABLES =====
let onlineUsersRef = null;
let challengesRef = null;
let activeChallenge = null;
let challengeWords = [];
let currentChallengeIndex = 0;
let myScore = 0;
let opponentScore = 0;
let presenceRef = null;


// ===== LIVE QUIZ VARIABLES =====
let quizOnlineUsersRef = null;
let quizChallengesRef = null;
let activeQuizChallenge = null;
let quizChallengeWords = [];
let currentQuizChallengeIndex = 0;
let myQuizScore = 0;
let opponentQuizScore = 0;
let quizChallengeListener = null;
let myQuizChallengeListener = null;
let shownQuizPopupIds = new Set();

// âœ… Challenge timeout constants
const CHALLENGE_TIMEOUT = 5 * 60 * 1000; // 5 minutes max per challenge
const TURN_TIMEOUT = 60 * 1000; // 60 seconds per turn
const OFFLINE_CHECK_INTERVAL = 10 * 1000; // Check every 10 seconds

let challengeTimeoutTimer = null;
let turnTimeoutTimer = null;
let offlineCheckTimer = null;


let userCoins = 0;
const COINS_PER_WIN = 5;
const MAX_COINS = 1000;


// ===== TOURNAMENT VARIABLES =====
let currentTournament = null;
let tournamentStage = 0;
let stage1Questions = [];
let stage1CurrentIndex = 0;
let stage1Score = 0;
let stage1Errors = 0;
let stage1Handicaps = 2;
let stage1TimeLeft = 600; // 10 minutes in seconds
let stage1Timer = null;

// ===== STAGE 2: AI AUDIO SPELLING =====
let stage2Words = [];
let stage2CurrentIndex = 0;
let stage2Score = 0;
let stage2Errors = 0;
let stage2TimeLeft = 900; // 15 minutes
let stage2Timer = null;
let stage2HandicapsRemaining = 1; // Base 1 + carried from Stage 1

// ===== TOURNAMENT STAGE 3 FUNCTIONS =====
let stage3Words = [];
let stage3CurrentIndex = 0;
let stage3Score = 0;
let stage3Errors = 0;
let stage3TimeLeft = 900; // 15 minutes
let stage3Timer = null;
let stage3HandicapsRemaining = 0;
let stage3CurrentLetterOrder = [];
let stage3DraggedElement = null;

// ===== LIVE STAGES 4-7 VARIABLES =====
let stage4RoomId = null;
let stage5RoomId = null;
let stage6RoomId = null;
let stage7RoomId = null;
let currentStageRoom = null;
let stageRoomListener = null;


// ===== LIVE ROOM VARIABLES =====
let localStream = null;
let liveRoomParticipants = new Map(); // userId -> {name, email, schoolId, stream, audioEnabled, videoEnabled}
let liveRoomListener = null;
let myAudioEnabled = true;
let myVideoEnabled = true;


// ===== AUTO-ELIMINATION VARIABLES =====
let stage3CompletionChecker = null;
const STAGE3_CUTOFF_TIME = 15 * 60 * 1000; // 15 minutes to complete Stage 3
const STAGE3_ELIMINATION_DELAY = 2 * 60 * 1000; // Wait 2 minutes after first completion before eliminating
let stage3FirstCompletionTime = null;


   // ===== CLASS SYSTEM VARIABLES =====
let myClass = null;
let classStudents = [];
let classAnnouncements = [];


// ===== LIVE SESSION VARIABLES =====
let liveSessionActive = false;
let liveSessionId = null;
let liveSessionListener = null;
let myPeerConnection = null;
let localAudioStream = null;
let peerConnections = new Map(); // userId -> RTCPeerConnection
let remoteStreams = new Map(); // userId -> MediaStream
let isMicMuted = false;
let sessionParticipants = new Map(); // userId -> {name, email, photoURL}
let isCoach = false; // Track if current user is coach
let coachMutedMe = false; // âœ… NEW: Track if coach has muted this student

        
// ===== ICE CANDIDATE QUEUE =====
const pendingIceCandidates = new Map(); // userId -> [candidates]
        
     // ===== INITIALIZE =====
document.addEventListener('DOMContentLoaded', function() {
    initializeAlphabet();
    initializeSpeechRecognition();
    
    // âœ… Cleanup old challenges on page load
    cleanupOldChallenges();
    
    // âœ… ADD SCROLL LISTENER FOR COIN DISPLAY
    window.addEventListener('scroll', function() {
        const coinDisplay = document.getElementById('coinDisplay');
        if (coinDisplay && coinDisplay.classList.contains('show')) {
            if (window.scrollY > 50) {
                coinDisplay.classList.add('scrolled');
            } else {
                coinDisplay.classList.remove('scrolled');
            }
        }
    });
    
    document.getElementById('searchInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') searchWord();
    });
    
  // Ã¢Å“â€¦ ADD MODAL CLOSE HANDLERS
    document.addEventListener('click', function(event) {
        // Close coach detail modal
        const coachModal = document.getElementById('coachDetailModal');
        if (event.target === coachModal) {
            closeCoachDetailModal();
        }
        
        // Close student detail modal
        const studentModal = document.getElementById('studentDetailModal');
        if (event.target === studentModal) {
            closeStudentDetailModal();
        }
        
        // Close leaderboard player modal
        const leaderboardModal = document.getElementById('leaderboardPlayerModal');
        if (event.target === leaderboardModal) {
            closeLeaderboardPlayerModal();
        }
        
        // Close quiz leaderboard player modal
        const quizLeaderboardModal = document.getElementById('quizLeaderboardPlayerModal');
        if (event.target === quizLeaderboardModal) {
            closeQuizLeaderboardPlayerModal();
        }
    });



   auth.onAuthStateChanged(async user => {
    if (user) {
        currentUser = user;
        
        console.log('ðŸ‘¤ User signed in:', user.email);
        console.log('ðŸ–¼ï¸ Auth photoURL:', user.photoURL);
        
        const userRef = db.collection('users').doc(user.uid);
        const userDoc = await userRef.get();
        
        if (!userDoc.exists) {
            await auth.signOut();
            alert('Account error. Please sign up again.');
            return;
        }
        
        const userData = userDoc.data();
        console.log('ðŸ“„ Firestore photoURL:', userData.photoURL);
        
        if (user.photoURL && !userData.photoURL) {
            console.log('ðŸ“„ Syncing photoURL to Firestore...');
            await userRef.update({
                photoURL: user.photoURL
            });
            console.log('âœ… PhotoURL synced!');
        }
        
        // âœ… INITIALIZE SPELLING STATS IF NOT EXISTS
        if (!userData.spellingStats) {
            console.log('ðŸ“„ Initializing spelling stats...');
            await userRef.update({
                spellingStats: {
                    totalChallenges: 0,
                    wins: 0,
                    losses: 0,
                    totalScore: 0,
                    winStreak: 0,
                    bestStreak: 0
                }
            });
            console.log('âœ… Spelling stats initialized!');
        }
        
        // âœ… CHECK ADMIN STATUS HERE (CRITICAL - RIGHT AFTER USER DATA IS LOADED)
        await checkAdminStatus();
        
        // âœ… ADD MY CLASS BUTTON
        const myClassBtn = document.getElementById('myClassBtn');
        if (!myClassBtn) {
            const classBtn = document.createElement('button');
            classBtn.id = 'myClassBtn';
            classBtn.className = 'my-profile-btn';
            classBtn.style.cssText = 'display: none; margin-top: 10px;';
            classBtn.onclick = () => {
                navigateTo('class');
                loadMyClass();
            };
            
            const sidebarUserInfo = document.getElementById('sidebarUserInfo');
            sidebarUserInfo.appendChild(classBtn);
        }
        
        try {
            if (userData && (userData.userType === 'student' || userData.userType === 'coach')) {
                document.getElementById('myClassBtn').innerHTML = 'ðŸ“š MY CLASS';
                document.getElementById('myClassBtn').style.display = 'block';
            }
        } catch (error) {
            console.error('Error checking class status:', error);
        }
        
        // âœ… CHECK USER TYPE AND HANDLE ACCORDINGLY
        if (userData.userType === 'parent') {
            // Parent user - no profile completion needed
            if (!userData.profileComplete) {
                await userRef.update({ profileComplete: true });
            }
            updateUIForAuthenticatedUser(user);
            
            // Navigate to parent dashboard
            navigateTo('parent-dashboard');
            return;
        }
        
        // STUDENT/COACH HANDLING
        if (!userData.profileComplete) {
            showVerificationModal(userData);
            return;
        }
        
        updateUIForAuthenticatedUser(user);
        
        // âœ… LOAD USER COINS (for students only)
        if (userData.userType === 'student') {
            await loadUserCoins(user.uid);
            await checkSubscriptionStatus();
        }
        
        await cleanupInvalidFavorites();
        
        await Promise.all([
            loadUserFavorites(user.uid),
            loadUserIncorrect(user.uid),
            loadUserSpellingFavorites(user.uid),
            loadUserSpellingIncorrect(user.uid)
        ]);
        
        // âœ… Initialize presence immediately on login (only for students/coaches)
        if (userData.userType !== 'parent') {
            await initializeOnlinePresence();
        }
        
        // Load appropriate dashboard
        if (userData.userType === 'student') {
            if (document.getElementById('student-dashboard-section').classList.contains('active')) {
                loadUserDashboard();
            }
        }
    } else {
        currentUser = null;
        isAdmin = false;
        
        // âœ… Clean up tournament listeners
        if (tournamentListeners) {
            tournamentListeners.forEach(unsubscribe => unsubscribe());
            tournamentListeners = [];
        }
        
        updateUIForGuestUser();
        updateAdminUI();
    }
});
    });
        
        
    
// ===== NAVIGATION =====
async function navigateTo(section, skipSidebarClose = false) {
    // âœ… CHECK SUBSCRIPTION FOR STUDENTS BEFORE ALLOWING NAVIGATION
    if (currentUser && !subscriptionActive && section !== 'student-dashboard' && section !== 'parent-dashboard' && section !== 'about') {
        try {
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            const userData = userDoc.data();
            
            // âœ… ADD: Only check if user data is fully loaded
            if (userData && userData.profileComplete && userData.userType === 'student') {
                showSubscriptionModal();
                return;
            }
        } catch (error) {
            console.error('Error checking subscription in navigation:', error);
            // Allow navigation on error
        }
    }
    
    // Check if user needs to be logged in
    if ((section === 'favorites' || section === 'incorrect-quiz' || 
         section === 'spelling-favorites' || section === 'spelling-incorrect' || 
         section === 'student-dashboard' || section === 'parent-dashboard') && !currentUser) {
        alert('Please sign in to access this feature');
        showAuthModal();
        return;
    }
    
    // âœ… PREVENT PARENTS FROM ACCESSING STUDENT FEATURES
    if (currentUser && section !== 'parent-dashboard' && section !== 'home' && section !== 'about' && section !== 'coaches' && section !== 'students') {
        try {
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            const userData = userDoc.data();
            
            if (userData && userData.userType === 'parent') {
                alert('âš ï¸ Parents can only access:\nâ€¢ Parent Dashboard\nâ€¢ Home\nâ€¢ About\nâ€¢ Coaches\nâ€¢ Students\n\nPlease use the Parent Dashboard to manage your child\'s account.');
                navigateTo('parent-dashboard');
                return;
            }
        } catch (error) {
            console.error('Error checking user type:', error);
        }
    }
    
    // âœ… Track current section BEFORE changing
    const currentSection = document.querySelector('.content-section.active')?.id.replace('-section', '');
    
    // âœ… RESET QUIZ STATE WHEN LEAVING QUIZ SECTION
    if (currentSection === 'quiz' && section !== 'quiz') {
        currentQuiz = null;
        currentQuestionIndex = 0;
        quizScore = 0;
        selectedGameLevel = '';
    }
    
    document.querySelectorAll('.content-section').forEach(sec => {
        sec.classList.remove('active');
    });
    
    const sectionId = section + '-section';
    const targetSection = document.getElementById(sectionId);
    if (targetSection) {
        targetSection.classList.add('active');
    }
    
    if (section === 'word-database') {
        // Always show level selection first
        document.getElementById('level-selection').style.display = 'block';
        document.getElementById('word-database-display').style.display = 'none';
    }
    
    // âœ… Reset Quiz section ONLY if coming from OUTSIDE
    if (section === 'quiz' && currentSection !== 'quiz') {
        document.getElementById('quiz-level-selection').style.display = 'block';
        document.getElementById('practice-quiz-container').innerHTML = '';
        selectedGameLevel = '';
    }
    
    // âœ… Reset Spelling section ONLY if coming from OUTSIDE
    if (section === 'spelling' && currentSection !== 'spelling') {
        document.getElementById('spelling-level-selection').style.display = 'block';
        document.getElementById('spelling-game').style.display = 'none';
        document.getElementById('spelling-results').style.display = 'none';
        selectedGameLevel = '';
    }
    
    if (section === 'favorites' && currentUser) {
        displayFavorites();
    }
    
    if (section === 'incorrect-quiz' && currentUser) {
        displayIncorrect();
    }
    
    if (section === 'spelling-favorites' && currentUser) {
        displaySpellingFavorites();
    }
    
    if (section === 'spelling-incorrect' && currentUser) {
        displaySpellingIncorrect();
    }
    
    // Load coaches section
    if (section === 'coaches') {
        await loadAndDisplayCoaches();
    }
    
    // Load students section
    if (section === 'students') {
        await loadAndDisplayStudents();
    }
    
    // âœ… Load student dashboard when navigating to it
    if (section === 'student-dashboard' && currentUser) {
        await loadUserDashboard();
    }
    
    // âœ… Load parent dashboard when navigating to it
    if (section === 'parent-dashboard' && currentUser) {
        await loadParentDashboard();
    }
    
    // âœ… LOAD ADMIN PANEL WHEN NAVIGATING TO IT
    if (section === 'admin' && currentUser) {
        console.log('ðŸŽ¯ Navigating to admin panel. isAdmin:', isAdmin);
        if (!isAdmin) {
            alert('âŒ Admin access required. Please sign in with an admin account.');
            navigateTo('home');
            return;
        }
        await loadAdminPanel();
    }
    
    if (!skipSidebarClose) {
        toggleSidebar(true);
    }

    if (section === 'tournaments') {
    await loadTournamentList();
}
   // Load class section
    if (section === 'class' && currentUser) {
        await loadMyClass();
} 
}

// ===== START LIVE SESSION (COACH ONLY) =====
async function startLiveSession() {
    if (!currentUser || !myClass) {
        alert('Unable to start session');
        return;
    }
    
    try {
        console.log('ðŸŽ¤ Starting live session...');
        
        // âœ… CRITICAL: Clean up any existing session first
        if (localAudioStream) {
            console.log('âš ï¸ Cleaning up existing audio stream');
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
        
        if (peerConnections.size > 0) {
            console.log('âš ï¸ Cleaning up existing peer connections');
            peerConnections.forEach(pc => pc.close());
            peerConnections.clear();
        }
        
        if (liveSessionListener) {
            console.log('âš ï¸ Cleaning up existing listener');
            liveSessionListener();
            liveSessionListener = null;
        }
        
        // âœ… CHECK IF SESSION IS ALREADY ACTIVE (REJOIN SCENARIO)
        const isRejoin = myClass.liveSessionActive && myClass.liveSessionId;
        
        // Get microphone permission with fresh stream
        console.log('ðŸŽ¤ Requesting microphone access...');
        localAudioStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            } 
        });
        
        // âœ… START WITH MIC MUTED
        localAudioStream.getAudioTracks().forEach(track => {
            track.enabled = false; // Start muted
        });
        isMicMuted = true;
        
        console.log('âœ… Microphone access granted (MUTED by default)');
        
        if (!isRejoin) {
            // Starting new session
            liveSessionId = myClass.id;
            
            const currentSessionCount = myClass.sessionCount || 0;
            
            await db.collection('classes').doc(myClass.id).update({
                liveSessionActive: true,
                liveSessionId: liveSessionId,
                liveSessionStartedAt: firebase.firestore.FieldValue.serverTimestamp(),
                liveSessionHost: currentUser.uid,
                sessionCount: currentSessionCount + 1
            });
            
            console.log('âœ… New session started');
            myClass.sessionCount = currentSessionCount + 1;
        } else {
            // Rejoining existing session
            liveSessionId = myClass.liveSessionId;
            console.log('ðŸ”„ Rejoining existing session:', liveSessionId);
        }
        
        // Add/update coach as participant
        await db.collection('classes')
            .doc(myClass.id)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .set({
                userId: currentUser.uid,
                name: currentUser.displayName || 'Coach',
                email: currentUser.email,
                photoURL: currentUser.photoURL || null,
                joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                micMuted: true, // âœ… Start muted
                coachMuted: false
            });
        
        liveSessionActive = true;
        isCoach = true;
        
        // Show live session UI for COACH
        const startBtn = document.getElementById('start-session-btn');
        const liveSessionContainer = document.getElementById('coach-live-session-active');
        
        if (startBtn) startBtn.style.display = 'none';
        if (liveSessionContainer) liveSessionContainer.style.display = 'block';
        
        // âœ… Set mic button to muted state
        const micBtn = document.getElementById('coach-toggle-mic-btn');
        if (micBtn) {
            micBtn.textContent = 'ðŸ”‡ Unmute';
            micBtn.style.background = '#dc3545';
        }
        
        // Update session count in UI
        updateCoachClassStats();
        
        // Listen for participants joining
        listenForSessionParticipants();
        
        const message = isRejoin ? 'âœ… Rejoined live session! (Mic is muted)' : 'âœ… Live session started! (Mic is muted - click Unmute to speak)';
        alert(message);
        
        console.log('âœ… Session start complete');
        
    } catch (error) {
        console.error('âŒ Error starting live session:', error);
        
        if (error.name === 'NotAllowedError') {
            alert('âŒ Microphone access denied. Please allow microphone access and try again.');
        } else if (error.name === 'NotFoundError') {
            alert('âŒ No microphone found. Please connect a microphone and try again.');
        } else {
            alert('Failed to start session: ' + error.message);
        }
        
        // Cleanup on error
        if (localAudioStream) {
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
    }
}
        
// ===== JOIN LIVE SESSION (STUDENT) =====
async function joinLiveSession() {
    if (!currentUser) {
        alert('Please sign in to join the session');
        return;
    }
    
    try {
        console.log('ðŸŽ¤ Joining live session...');
        
        // âœ… Set cleanup flag
        isCleaningUp = true;
        
        // âœ… CRITICAL: Clean up any existing session first
        if (localAudioStream) {
            console.log('âš ï¸ Cleaning up existing audio stream');
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
        
        if (peerConnections.size > 0) {
            console.log('âš ï¸ Cleaning up existing peer connections');
            peerConnections.forEach(pc => pc.close());
            peerConnections.clear();
        }
        
        if (liveSessionListener) {
            console.log('âš ï¸ Cleaning up existing listener');
            liveSessionListener();
            liveSessionListener = null;
        }
        
        // Clear pending ICE candidates
        pendingIceCandidates.clear();
        
        // Get user data
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        
        if (!userData.classId) {
            alert('You are not enrolled in a class');
            isCleaningUp = false;
            return;
        }
        
        liveSessionId = userData.classId;
        
        // Check if session is actually active
        const classDoc = await db.collection('classes').doc(userData.classId).get();
        const classData = classDoc.data();
        
        if (!classData.liveSessionActive || !classData.liveSessionId) {
            alert('âŒ This session is no longer active');
            isCleaningUp = false;
            return;
        }
        
        console.log('âœ… Session is active, joining...');
        
        // âœ… Check if we're already in the participants list (rejoining scenario)
        const existingParticipant = await db.collection('classes')
            .doc(userData.classId)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .get();

        if (existingParticipant.exists) {
            console.log('ðŸ”„ Rejoining - cleaning up old participant entry and signaling');
            
            // âœ… Clean up old signaling messages FIRST
            await cleanupOldSignalingMessages(currentUser.uid);
            
            // Delete old entry to force clean reconnection
            await db.collection('classes')
                .doc(userData.classId)
                .collection('sessionParticipants')
                .doc(currentUser.uid)
                .delete();
            
            // âœ… Wait for coach to detect removal and clean up
            console.log('â³ Waiting 5 seconds for complete cleanup...');
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // âœ… Clean up signaling AGAIN (in case coach sent messages during deletion)
            await cleanupOldSignalingMessages(currentUser.uid);
        }
        
        // Get microphone permission with fresh stream
        console.log('ðŸŽ¤ Requesting microphone access...');
        localAudioStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            } 
        });
        
        // âœ… START WITH MIC MUTED
        localAudioStream.getAudioTracks().forEach(track => {
            track.enabled = false; // Start muted
        });
        isMicMuted = true;
        
        console.log('âœ… Microphone access granted (MUTED by default)');
        
        // âœ… Clear cleanup flag BEFORE starting listeners
        isCleaningUp = false;
        
        // Add to session participants (this triggers coach to create new connection)
        console.log('ðŸ“ Adding to session participants...');
        await db.collection('classes')
            .doc(userData.classId)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .set({
                userId: currentUser.uid,
                name: userData.name || 'Student',
                email: userData.email,
                photoURL: userData.photoURL || null,
                joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                micMuted: true, // âœ… Start muted
                coachMuted: false
            });
        
        console.log('âœ… Added to session participants');
        
        liveSessionActive = true;
        
        // Hide join button and show active session UI
        const joinContainer = document.getElementById('live-session-join-container');
        const activeSessionUI = document.getElementById('student-live-session-active');
        
        if (joinContainer) joinContainer.style.display = 'none';
        if (activeSessionUI) activeSessionUI.style.display = 'block';
        
        // âœ… Set mic button to muted state
        const micBtn = document.getElementById('student-toggle-mic-btn');
        if (micBtn) {
            micBtn.textContent = 'ðŸ”‡ Unmute';
            micBtn.style.background = '#dc3545';
        }
        
        // Listen for participants (this will trigger coach's offer)
        listenForSessionParticipants();
        
        alert('âœ… Joined live session! (Mic is muted - click Unmute when ready to speak)');
        
        console.log('âœ… Joined live session successfully');
        
    } catch (error) {
        console.error('âŒ Error joining session:', error);
        
        // âœ… Clear cleanup flag on error
        isCleaningUp = false;
        
        let errorMessage = 'Failed to join session. ';
        
        if (error.name === 'NotAllowedError') {
            errorMessage += 'Microphone access was denied. Please allow microphone access in your browser settings and try again.';
        } else if (error.name === 'NotFoundError') {
            errorMessage += 'No microphone found. Please connect a microphone and try again.';
        } else if (error.message) {
            errorMessage += error.message;
        } else {
            errorMessage += 'Please check your microphone permissions and try again.';
        }
        
        alert(errorMessage);
        
        // Cleanup on error
        if (localAudioStream) {
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
        
        // Remove from participants if we added ourselves
        try {
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            const userData = userDoc.data();
            if (userData.classId) {
                await db.collection('classes')
                    .doc(userData.classId)
                    .collection('sessionParticipants')
                    .doc(currentUser.uid)
                    .delete();
            }
        } catch (cleanupError) {
            console.error('Error cleaning up after failed join:', cleanupError);
        }
    }
}

    let isCleaningUp = false; // Add this at the top with your other global variables
    
// ===== LISTEN FOR SESSION PARTICIPANTS =====
function listenForSessionParticipants() {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('ðŸ‘‚ Setting up participant listener for class:', classId);
    
    liveSessionListener = db.collection('classes')
        .doc(classId)
        .collection('sessionParticipants')
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const participant = change.doc.data();
                    
                    console.log('âž• Participant added:', participant.name, participant.userId);
                    
                    if (participant.userId !== currentUser.uid) {
                        if (isCoach) {
                            console.log('ðŸ‘‘ Coach creating connection to:', participant.name);
                            
                            // âœ… Close any existing connection first
                            if (peerConnections.has(participant.userId)) {
                                console.log('ðŸ—‘ï¸ Closing old connection before creating new one');
                                const oldPc = peerConnections.get(participant.userId);
                                oldPc.close();
                                peerConnections.delete(participant.userId);
                            }
                            
                            // âœ… Clear any pending candidates
                            if (pendingIceCandidates.has(participant.userId)) {
                                pendingIceCandidates.delete(participant.userId);
                            }
                            
                            // âœ… CRITICAL: Clean up old signaling messages
                            await cleanupOldSignalingMessages(participant.userId);
                            
                            // âœ… Small delay to ensure cleanup completes
                            await new Promise(resolve => setTimeout(resolve, 500));
                            
                            // Create new connection
                            createPeerConnection(participant.userId, participant, true);
                        } else {
                            console.log('ðŸ‘¨â€ðŸŽ“ Student waiting for offer from coach');
                        }
                    }
                    
                    sessionParticipants.set(participant.userId, participant);
                }
                
                if (change.type === 'removed') {
                    const participant = change.doc.data();
                    console.log('âž– Participant removed:', participant.name);
                    
                    closePeerConnection(participant.userId);
                    sessionParticipants.delete(participant.userId);
                }
                
                if (change.type === 'modified') {
                    const participant = change.doc.data();
                    sessionParticipants.set(participant.userId, participant);
                    
                    // âœ… Check if coach muted/unmuted this student
                    if (participant.userId === currentUser.uid && !isCoach) {
                        const wasCoachMuted = coachMutedMe;
                        coachMutedMe = participant.coachMuted || false;
                        
                        if (coachMutedMe && !wasCoachMuted) {
                            console.log('ðŸ”‡ Coach muted you');
                            if (localAudioStream) {
                                const audioTrack = localAudioStream.getAudioTracks()[0];
                                if (audioTrack) {
                                    audioTrack.enabled = false;
                                    isMicMuted = true;
                                    
                                    const btn = document.getElementById('student-toggle-mic-btn');
                                    if (btn) {
                                        btn.textContent = 'ðŸ”‡ Unmute';
                                        btn.style.background = '#dc3545';
                                    }
                                }
                            }
                            alert('ðŸ”‡ Your coach has muted you');
                        } else if (!coachMutedMe && wasCoachMuted) {
                            console.log('ðŸ”Š Coach unmuted you');
                            alert('ðŸ”Š Your coach has unmuted you. You can now speak.');
                        }
                    }
                }
            });
            
            updateParticipantsList();
        });
    
    // Listen for WebRTC signaling
    listenForSignaling();
}

        
// ===== CREATE PEER CONNECTION =====
async function createPeerConnection(userId, participant, isInitiator = true) {
    try {
        console.log('ðŸ”— Creating peer connection with:', participant.name, 'isInitiator:', isInitiator);
        
        // âœ… CRITICAL: Ensure we have a local audio stream
        if (!localAudioStream || localAudioStream.getTracks().length === 0) {
            console.error('âŒ No local audio stream available! Re-requesting...');
            try {
                localAudioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                // Apply muted state to new stream
                localAudioStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMicMuted;
                });
                console.log('âœ… Re-acquired microphone access');
            } catch (error) {
                console.error('âŒ Failed to re-acquire microphone:', error);
                throw error;
            }
        }
        
        // âœ… Close existing connection if it exists
        if (peerConnections.has(userId)) {
            console.log('âš ï¸ Closing existing connection before creating new one');
            const oldPc = peerConnections.get(userId);
            oldPc.close();
            peerConnections.delete(userId);
            
            // âœ… Remove old audio element
            const oldAudio = document.getElementById(`audio_${userId}`);
            if (oldAudio) {
                oldAudio.pause();
                oldAudio.srcObject = null;
                oldAudio.remove();
            }
        }
        
        const peerConnection = new RTCPeerConnection(iceServers);
        
        // âœ… CRITICAL: Temporarily enable ALL tracks for negotiation (even if muted)
        console.log('ðŸŽ¤ Adding local audio tracks to peer connection');
        const tracksToRestore = [];
        
        localAudioStream.getTracks().forEach(track => {
            const wasEnabled = track.enabled;
            tracksToRestore.push({ track, wasEnabled });
            
            // FORCE enable for connection setup
            track.enabled = true;
            console.log('   Track:', track.kind, 'forced enabled (was:', wasEnabled, ')');
            
            peerConnection.addTrack(track, localAudioStream);
            console.log('   âœ… Track added to peer connection');
        });
        
        // âœ… Restore original enabled state after connection is established
       peerConnection.onconnectionstatechange = () => {
    console.log(`Connection state with ${participant.name}:`, peerConnection.connectionState);
    
    if (peerConnection.connectionState === 'connected') {
        console.log('âœ… Peer connection established with:', participant.name);
        
        // âœ… FIX: Restore CURRENT mute state, not old state
        setTimeout(() => {
            if (localAudioStream) {
                localAudioStream.getTracks().forEach(track => {
                    // Use CURRENT isMicMuted state, not stored state
                    track.enabled = !isMicMuted;
                    console.log('ðŸ”„ Restored track to CURRENT state - enabled:', !isMicMuted, '(isMicMuted:', isMicMuted, ')');
                });
            }
        }, 500);
    } else if (peerConnection.connectionState === 'failed') {
                console.error('âŒ Connection failed with:', participant.name);
            } else if (peerConnection.connectionState === 'disconnected') {
                console.warn('âš ï¸ Connection disconnected with:', participant.name);
            }
        };
        
        peerConnection.ontrack = (event) => {
            console.log('ðŸ“¥ Received track from:', participant.name);
            console.log('   Track kind:', event.track.kind);
            console.log('   Track enabled:', event.track.enabled);
            console.log('   Track readyState:', event.track.readyState);
            
            if (event.streams.length === 0) {
                console.error('âŒ No streams in track event!');
                return;
            }
            
            const remoteStream = event.streams[0];
            console.log('   Stream audio tracks:', remoteStream.getAudioTracks().length);
            
            remoteStreams.set(userId, remoteStream);
            
            // Remove old audio element if exists
            const oldAudio = document.getElementById(`audio_${userId}`);
            if (oldAudio) {
                console.log('ðŸ—‘ï¸ Removing old audio element');
                oldAudio.pause();
                oldAudio.srcObject = null;
                oldAudio.remove();
            }
            
            // âœ… Wait for track to be fully ready
            setTimeout(() => {
                const audioElement = document.createElement('audio');
                audioElement.id = `audio_${userId}`;
                audioElement.autoplay = true;
                audioElement.playsInline = true;
                audioElement.volume = 1.0;
                audioElement.srcObject = remoteStream;
                
                audioElement.onloadedmetadata = () => {
                    console.log('âœ… Audio metadata loaded for:', participant.name);
                };
                
                audioElement.onplay = () => {
                    console.log('âœ… Audio started playing for:', participant.name);
                };
                
                audioElement.onerror = (e) => {
                    console.error('âŒ Audio element error:', e);
                };
                
                let container = document.getElementById('remote-audio-container');
                if (!container) {
                    console.warn('âš ï¸ remote-audio-container not found, creating it');
                    container = document.createElement('div');
                    container.id = 'remote-audio-container';
                    container.style.display = 'none';
                    document.body.appendChild(container);
                }
                container.appendChild(audioElement);
                
                console.log('âœ… Audio element created and added');
                
                // âœ… Force play with user interaction fallback
                const playPromise = audioElement.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('âœ… Audio playing successfully for:', participant.name);
                        })
                        .catch(err => {
                            console.error('âŒ Error playing audio:', err);
                            if (err.name === 'NotAllowedError') {
                                alert(`Click OK to enable audio from ${participant.name}`);
                                audioElement.play()
                                    .then(() => console.log('âœ… Audio playing after user interaction'))
                                    .catch(e => console.error('âŒ Still failed:', e));
                            }
                        });
                }
            }, 100);
        };
        
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('ðŸ§Š Sending ICE candidate to:', participant.name);
                sendIceCandidate(userId, event.candidate);
            }
        };
        
        peerConnection.oniceconnectionstatechange = () => {
            console.log(`ICE connection state with ${participant.name}:`, peerConnection.iceConnectionState);
        };
        
        peerConnections.set(userId, peerConnection);
        
        if (isInitiator) {
            console.log('ðŸ“¤ Creating and sending offer to:', participant.name);
            const offer = await peerConnection.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: false
            });
            await peerConnection.setLocalDescription(offer);
            await sendOffer(userId, offer);
            console.log('âœ… Offer sent to:', participant.name);
        }
        
        return peerConnection;
        
    } catch (error) {
        console.error('âŒ Error creating peer connection:', error);
        throw error;
    }
}

    
        
// ===== HANDLE OFFER =====
async function handleOffer(fromUserId, offer) {
    try {
        console.log('ðŸ“¨ Handling offer from user:', fromUserId);
        
        // âœ… CRITICAL: Ensure we have a local audio stream
        if (!localAudioStream || localAudioStream.getTracks().length === 0) {
            console.error('âŒ No local audio stream! Re-requesting...');
            try {
                localAudioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                localAudioStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMicMuted;
                });
                console.log('âœ… Re-acquired microphone for handling offer');
            } catch (error) {
                console.error('âŒ Failed to re-acquire microphone:', error);
                throw error;
            }
        }
        
        // âœ… Close any existing connection first
        let peerConnection = peerConnections.get(fromUserId);
        if (peerConnection) {
            console.log('âš ï¸ Closing existing connection before handling offer');
            peerConnection.close();
            peerConnections.delete(fromUserId);
            
            const oldAudio = document.getElementById(`audio_${fromUserId}`);
            if (oldAudio) {
                oldAudio.pause();
                oldAudio.srcObject = null;
                oldAudio.remove();
            }
        }
        
        if (pendingIceCandidates.has(fromUserId)) {
            console.log('ðŸ—‘ï¸ Clearing old queued ICE candidates');
            pendingIceCandidates.delete(fromUserId);
        }
        
        // Get participant info
        const classId = myClass ? myClass.id : liveSessionId;
        const participantDoc = await db.collection('classes')
            .doc(classId)
            .collection('sessionParticipants')
            .doc(fromUserId)
            .get();
        
        if (!participantDoc.exists) {
            console.error('âŒ Participant not found:', fromUserId);
            return;
        }
        
        const participant = participantDoc.data();
        console.log('ðŸ‘¤ Creating connection for:', participant.name);
        
        // Create new peer connection
        peerConnection = new RTCPeerConnection(iceServers);
        
        // âœ… CRITICAL: Track original states and force enable
        console.log('ðŸŽ¤ Adding local audio tracks (answering)');
        const tracksToRestore = [];
        
        localAudioStream.getTracks().forEach(track => {
            const wasEnabled = track.enabled;
            tracksToRestore.push({ track, wasEnabled });
            
            // FORCE enable for connection
            track.enabled = true;
            console.log('   Track:', track.kind, 'forced enabled (was:', wasEnabled, ')');
            
            peerConnection.addTrack(track, localAudioStream);
            console.log('   âœ… Track added');
        });
        
        // Handle remote audio
        peerConnection.ontrack = (event) => {
            console.log('ðŸ“¥ Received track from:', participant.name);
            console.log('   Track kind:', event.track.kind);
            console.log('   Track enabled:', event.track.enabled);
            console.log('   Track readyState:', event.track.readyState);
            
            if (event.streams.length === 0) {
                console.error('âŒ No streams!');
                return;
            }
            
            const remoteStream = event.streams[0];
            console.log('   Stream audio tracks:', remoteStream.getAudioTracks().length);
            remoteStreams.set(fromUserId, remoteStream);
            
            let audioElement = document.getElementById(`audio_${fromUserId}`);
            if (audioElement) {
                console.log('ðŸ—‘ï¸ Removing old audio element');
                audioElement.pause();
                audioElement.srcObject = null;
                audioElement.remove();
            }
            
            setTimeout(() => {
                audioElement = document.createElement('audio');
                audioElement.id = `audio_${fromUserId}`;
                audioElement.autoplay = true;
                audioElement.playsInline = true;
                audioElement.volume = 1.0;
                audioElement.srcObject = remoteStream;
                
                audioElement.onloadedmetadata = () => {
                    console.log('âœ… Audio metadata loaded for:', participant.name);
                };
                
                audioElement.onplay = () => {
                    console.log('âœ… Audio started playing for:', participant.name);
                };
                
                audioElement.onerror = (e) => {
                    console.error('âŒ Audio element error:', e);
                };
                
                let container = document.getElementById('remote-audio-container');
                if (!container) {
                    console.warn('âš ï¸ Container not found, creating it');
                    container = document.createElement('div');
                    container.id = 'remote-audio-container';
                    container.style.display = 'none';
                    document.body.appendChild(container);
                }
                container.appendChild(audioElement);
                
                const playPromise = audioElement.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => console.log('âœ… Audio playing from:', participant.name))
                        .catch(err => {
                            console.error('âŒ Playback error:', err);
                            if (err.name === 'NotAllowedError') {
                                alert(`Click OK to enable audio from ${participant.name}`);
                                audioElement.play();
                            }
                        });
                }
            }, 100);
        };
        
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('ðŸ§Š Sending ICE candidate');
                sendIceCandidate(fromUserId, event.candidate);
            }
        };
        
       peerConnection.onconnectionstatechange = () => {
    console.log(`Connection state with ${participant.name}:`, peerConnection.connectionState);
    
    if (peerConnection.connectionState === 'connected') {
        console.log('âœ… Peer connection established with:', participant.name);
        
        // âœ… FIX: Restore CURRENT mute state, not old state
        setTimeout(() => {
            if (localAudioStream) {
                localAudioStream.getTracks().forEach(track => {
                    // Use CURRENT isMicMuted state, not stored state
                    track.enabled = !isMicMuted;
                    console.log('ðŸ”„ Restored track to CURRENT state - enabled:', !isMicMuted, '(isMicMuted:', isMicMuted, ')');
                });
            }
        }, 500);
    } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                console.warn(`âš ï¸ Connection ${peerConnection.connectionState} with ${participant.name}`);
            }
        };
        
        peerConnection.oniceconnectionstatechange = () => {
            console.log(`ICE connection state with ${participant.name}:`, peerConnection.iceConnectionState);
        };
        
        peerConnections.set(fromUserId, peerConnection);
        
        // âœ… Set remote description (the offer)
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        console.log('âœ… Remote description set');
        
        // âœ… Create and send answer
        const answer = await peerConnection.createAnswer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: false
        });
        await peerConnection.setLocalDescription(answer);
        
        await sendAnswer(fromUserId, answer);
        console.log('âœ… Answer sent to:', participant.name);
        
        // âœ… Process any queued ICE candidates
        if (pendingIceCandidates.has(fromUserId)) {
            const queued = pendingIceCandidates.get(fromUserId);
            console.log(`ðŸ“‹ Processing ${queued.length} queued ICE candidates after offer`);
            
            for (const candidate of queued) {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log('âœ… Queued ICE candidate added');
                } catch (err) {
                    console.error('âŒ Error adding queued candidate:', err);
                }
            }
            
            pendingIceCandidates.delete(fromUserId);
        }
        
    } catch (error) {
        console.error('âŒ Error handling offer:', error);
    }
}
        
// ===== HANDLE ANSWER =====
async function handleAnswer(fromUserId, answer) {
    try {
        console.log('ðŸ“¨ Handling answer from user:', fromUserId);
        
        const peerConnection = peerConnections.get(fromUserId);
        
        if (!peerConnection) {
            console.warn('âš ï¸ No peer connection found for:', fromUserId, '- ignoring answer');
            return;
        }
        
        const currentState = peerConnection.signalingState;
        console.log('   Current signaling state:', currentState);
        
        // âœ… Only process answer if we're waiting for one
        if (currentState === 'have-local-offer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            console.log('âœ… Answer processed from:', fromUserId);
            
            // âœ… Process any queued ICE candidates now that remote description is set
            if (pendingIceCandidates.has(fromUserId)) {
                const queued = pendingIceCandidates.get(fromUserId);
                console.log(`ðŸ“‹ Processing ${queued.length} queued ICE candidates after answer`);
                
                for (const candidate of queued) {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log('âœ… Queued ICE candidate added');
                    } catch (err) {
                        console.error('âŒ Error adding queued candidate:', err);
                    }
                }
                
                pendingIceCandidates.delete(fromUserId);
            }
        } else if (currentState === 'stable') {
            console.log('âš ï¸ Already in stable state - ignoring duplicate/stale answer');
        } else if (currentState === 'have-remote-offer') {
            console.warn('âš ï¸ Wrong role - we should be answering, not receiving answer. Ignoring.');
        } else {
            console.warn('âš ï¸ Unexpected signaling state:', currentState, '- ignoring answer');
        }
        
    } catch (error) {
        // âœ… Catch and log without crashing
        console.error('âŒ Error handling answer (non-fatal):', error.message);
    }
}
        
async function getParticipantData(userId) {
    const classId = myClass ? myClass.id : liveSessionId;
    const participantDoc = await db.collection('classes')
        .doc(classId)
        .collection('sessionParticipants')
        .doc(userId)
        .get();
    
    if (participantDoc.exists) {
        return participantDoc.data();
    }
    return { userId, name: 'Unknown', email: '' };
}


// ===== CLEANUP OLD SIGNALING MESSAGES =====
async function cleanupOldSignalingMessages(userId) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('ðŸ—‘ï¸ Cleaning up ALL signaling messages for user:', userId);
    
    try {
        // âœ… Delete ALL signaling messages in both directions
        const deletions = [];
        
        // Offers
        const offersFrom = await db.collection('classes').doc(classId).collection('offers').where('from', '==', userId).get();
        const offersTo = await db.collection('classes').doc(classId).collection('offers').where('to', '==', userId).get();
        offersFrom.forEach(doc => deletions.push(doc.ref.delete()));
        offersTo.forEach(doc => deletions.push(doc.ref.delete()));
        
        // Answers
        const answersFrom = await db.collection('classes').doc(classId).collection('answers').where('from', '==', userId).get();
        const answersTo = await db.collection('classes').doc(classId).collection('answers').where('to', '==', userId).get();
        answersFrom.forEach(doc => deletions.push(doc.ref.delete()));
        answersTo.forEach(doc => deletions.push(doc.ref.delete()));
        
        // ICE Candidates
        const candidatesFrom = await db.collection('classes').doc(classId).collection('iceCandidates').where('from', '==', userId).get();
        const candidatesTo = await db.collection('classes').doc(classId).collection('iceCandidates').where('to', '==', userId).get();
        candidatesFrom.forEach(doc => deletions.push(doc.ref.delete()));
        candidatesTo.forEach(doc => deletions.push(doc.ref.delete()));
        
        // Wait for all deletions to complete
        await Promise.all(deletions);
        
        console.log(`âœ… Deleted ${deletions.length} old signaling messages for ${userId}`);
        
    } catch (error) {
        console.error('Error cleaning up signaling:', error);
    }
}

        
// ===== WEBRTC SIGNALING =====
function listenForSignaling() {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('ðŸ‘‚ Setting up signaling listeners for class:', classId);
    
    // Listen for offers
    db.collection('classes')
        .doc(classId)
        .collection('offers')
        .where('to', '==', currentUser.uid)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    
                    // âœ… Delete IMMEDIATELY before processing
                    const docRef = change.doc.ref;
                    docRef.delete().catch(e => console.error('Error deleting offer:', e));
                    
                    // âœ… Ignore if we're cleaning up
                    if (isCleaningUp) {
                        console.log('â¸ï¸ Ignoring offer during cleanup');
                        return;
                    }
                    
                    console.log('ðŸ“¨ Received offer from:', data.from);
                    await handleOffer(data.from, data.offer);
                }
            });
        });
    
    // Listen for answers
    db.collection('classes')
        .doc(classId)
        .collection('answers')
        .where('to', '==', currentUser.uid)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    const fromUserId = data.from;
                    
                    // âœ… DELETE IMMEDIATELY FIRST
                    const docRef = change.doc.ref;
                    docRef.delete().catch(e => console.error('Error deleting answer:', e));
                    
                    // âœ… Ignore if we're cleaning up
                    if (isCleaningUp) {
                        console.log('â¸ï¸ Ignoring answer during cleanup');
                        return;
                    }
                    
                    // âœ… CHECK STATE BEFORE CALLING handleAnswer
                    const peerConnection = peerConnections.get(fromUserId);
                    if (!peerConnection) {
                        console.warn('âš ï¸ No peer connection for answer from:', fromUserId);
                        return;
                    }
                    
                    if (peerConnection.signalingState !== 'have-local-offer') {
                        console.log('â­ï¸ Ignoring answer - wrong state:', peerConnection.signalingState);
                        return;
                    }
                    
                    console.log('ðŸ“¨ Processing answer from:', fromUserId);
                    await handleAnswer(fromUserId, data.answer);
                }
            });
        });
    
    // Listen for ICE candidates
    db.collection('classes')
        .doc(classId)
        .collection('iceCandidates')
        .where('to', '==', currentUser.uid)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    
                    // âœ… Delete immediately
                    const docRef = change.doc.ref;
                    docRef.delete().catch(e => console.error('Error deleting candidate:', e));
                    
                    // âœ… Ignore if we're cleaning up
                    if (isCleaningUp) {
                        console.log('â¸ï¸ Ignoring ICE candidate during cleanup');
                        return;
                    }
                    
                    console.log('ðŸ“¨ Received ICE candidate from:', data.from);
                    await handleIceCandidate(data.from, data.candidate);
                }
            });
        });
}
        
// ===== SEND OFFER =====
async function sendOffer(toUserId, offer) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('ðŸ“¤ Sending offer to:', toUserId);
    
    await db.collection('classes')
        .doc(classId)
        .collection('offers')
        .add({
            from: currentUser.uid,
            to: toUserId,
            offer: {
                type: offer.type,
                sdp: offer.sdp
            },
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
}


// ===== SEND ANSWER =====
async function sendAnswer(toUserId, answer) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('ðŸ“¤ Sending answer to:', toUserId);
    
    await db.collection('classes')
        .doc(classId)
        .collection('answers')
        .add({
            from: currentUser.uid,
            to: toUserId,
            answer: {
                type: answer.type,
                sdp: answer.sdp
            },
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
}
        

// ===== SEND ICE CANDIDATE =====
async function sendIceCandidate(toUserId, candidate) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    await db.collection('classes')
        .doc(classId)
        .collection('iceCandidates')
        .add({
            from: currentUser.uid,
            to: toUserId,
            candidate: candidate.toJSON(),
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
}


// ===== HANDLE ICE CANDIDATE =====
async function handleIceCandidate(fromUserId, candidate) {
    try {
        const peerConnection = peerConnections.get(fromUserId);
        
        if (!peerConnection) {
            console.warn('âš ï¸ No peer connection found for:', fromUserId, '- ignoring ICE candidate');
            return;
        }
        
        // Ã¢Å“â€¦ Check if remote description is set
        if (peerConnection.remoteDescription && peerConnection.remoteDescription.type) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            console.log('âœ… ICE candidate added from:', fromUserId);
            
            // Ã¢Å“â€¦ Process any queued candidates
            if (pendingIceCandidates.has(fromUserId)) {
                const queued = pendingIceCandidates.get(fromUserId);
                console.log(`ðŸ“‹ Processing ${queued.length} queued ICE candidates`);
                
                for (const queuedCandidate of queued) {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(queuedCandidate));
                        console.log('âœ… Queued ICE candidate added');
                    } catch (err) {
                        console.error('âŒ Error adding queued candidate:', err);
                    }
                }
                
                pendingIceCandidates.delete(fromUserId);
            }
        } else {
            // Ã¢Å“â€¦ Queue the candidate for later
            console.log('ðŸ“¥ Queueing ICE candidate (remote description not ready)');
            if (!pendingIceCandidates.has(fromUserId)) {
                pendingIceCandidates.set(fromUserId, []);
            }
            pendingIceCandidates.get(fromUserId).push(candidate);
        }
    } catch (error) {
        console.error('âŒ Error handling ICE candidate:', error);
    }
}
// ===== TOGGLE MICROPHONE =====
async function toggleMicrophone() {
    if (!localAudioStream) {
        console.error('âŒ No local audio stream to toggle!');
        return;
    }
    
    const audioTrack = localAudioStream.getAudioTracks()[0];
    if (!audioTrack) {
        console.error('âŒ No audio track found!');
        return;
    }
    
    // Toggle the track
    audioTrack.enabled = !audioTrack.enabled;
    isMicMuted = !audioTrack.enabled;
    
    console.log('ðŸŽ¤ Microphone', isMicMuted ? 'MUTED' : 'UNMUTED');
    
    // Update button based on user type
    const btnId = isCoach ? 'coach-toggle-mic-btn' : 'student-toggle-mic-btn';
    const btn = document.getElementById(btnId);
    
    if (btn) {
        if (isMicMuted) {
            btn.textContent = 'ðŸ”‡ Unmute';
            btn.style.background = '#dc3545';
        } else {
            btn.textContent = 'ðŸŽ¤ Mute';
            btn.style.background = '#28a745';
        }
    }
    
    // Update in Firestore
    const classId = myClass ? myClass.id : liveSessionId;
    if (classId) {
        try {
            await db.collection('classes')
                .doc(classId)
                .collection('sessionParticipants')
                .doc(currentUser.uid)
                .update({ 
                    micMuted: isMicMuted,
                    coachMuted: false
                });
        } catch (error) {
            console.error('Error updating mic status in Firestore:', error);
        }
    }
}

  // ===== MUTE PARTICIPANT (COACH ONLY) =====
async function muteParticipant(userId, participantName) {
    if (!isCoach) {
        alert('Only coaches can mute participants');
        return;
    }
    
    if (!confirm(`MUTE ${participantName}?\n\nNote: Only the student can unmute themselves.`)) {
        return;
    }
    
    try {
        const classId = myClass.id;
        
        // Update in Firestore - force mute
        await db.collection('classes')
            .doc(classId)
            .collection('sessionParticipants')
            .doc(userId)
            .update({ 
                micMuted: true,
                coachMuted: true // Track that coach did this
            });
        
        console.log(`âœ… Muted ${participantName}`);
        
        // Update local map
        const participant = sessionParticipants.get(userId);
        if (participant) {
            participant.micMuted = true;
            participant.coachMuted = true;
            sessionParticipants.set(userId, participant);
        }
        
        // Update UI
        updateParticipantsList();
        
    } catch (error) {
        console.error('Error muting participant:', error);
        alert('Failed to mute participant: ' + error.message);
    }
}
        
// ===== UPDATE PARTICIPANTS LIST =====
function updateParticipantsList() {
    const containerId = isCoach ? 'coach-session-participants-list' : 'student-session-participants-list';
    const container = document.getElementById(containerId);
    
    if (!container) {
        console.error('Participants container not found:', containerId);
        return;
    }
    
    if (sessionParticipants.size === 0) {
        container.innerHTML = '<p style="color: #666;">No participants yet</p>';
        return;
    }
    
    // Update participant count for coach
    if (isCoach) {
        const countEl = document.getElementById('participant-count');
        if (countEl) countEl.textContent = sessionParticipants.size;
    }
    
    container.innerHTML = Array.from(sessionParticipants.values())
        .map(participant => {
            const avatarHtml = participant.photoURL 
                ? `<div class="coach-avatar" style="width: 40px; height: 40px; background-image: url('${participant.photoURL}'); background-size: cover;"></div>`
                : `<div class="coach-avatar" style="width: 40px; height: 40px;">${(participant.name || 'U').charAt(0).toUpperCase()}</div>`;
            
            const micStatus = participant.micMuted ? 'ðŸ”‡' : 'ðŸŽ¤';
            const isCurrentUser = participant.userId === currentUser.uid;
            
            // âœ… Coach can ONLY mute (not unmute) other participants
            const coachControls = isCoach && !isCurrentUser ? `
                <button 
                    onclick="muteParticipant('${participant.userId}', '${participant.name.replace(/'/g, "\\'")}')"
                    style="
                        background: #dc3545;
                        color: white;
                        border: none;
                        padding: 8px 15px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 0.9rem;
                        font-weight: bold;
                        transition: all 0.3s;
                    "
                    onmouseover="this.style.opacity='0.8'"
                    onmouseout="this.style.opacity='1'"
                >
                    ðŸ”‡ Mute
                </button>
            ` : '';
            
            // âœ… Show if coach has muted them
            const coachMutedLabel = participant.coachMuted ? 
                '<span style="color: #dc3545; font-size: 0.8rem; font-weight: bold;">(Coach Muted)</span>' : '';
            
            return `
                <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: white; border-radius: 8px; margin-bottom: 10px;">
                    ${avatarHtml}
                    <div style="flex: 1;">
                        <div style="font-weight: bold; color: #0d3b66;">
                            ${participant.name}${isCurrentUser ? ' (You)' : ''}
                            ${coachMutedLabel}
                        </div>
                        <div style="font-size: 0.9rem; color: #666;">${participant.email}</div>
                    </div>
                    <div style="font-size: 1.5rem;">${micStatus}</div>
                    ${coachControls}
                </div>
            `;
        }).join('');
}

function listenForSessionParticipants() {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('ðŸ‘‚ Setting up participant listener for class:', classId);
    
    liveSessionListener = db.collection('classes')
        .doc(classId)
        .collection('sessionParticipants')
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(change => {
                if (change.type === 'added') {
                    const participant = change.doc.data();
                    
                    console.log('âž• Participant added:', participant.name, participant.userId);
                    
                    if (participant.userId !== currentUser.uid) {
                        if (isCoach) {
                            console.log('ðŸ‘‘ Coach creating connection to:', participant.name);
                            createPeerConnection(participant.userId, participant, true);
                        } else {
                            console.log('ðŸ‘¨â€ðŸŽ“ Student waiting for offer from coach');
                        }
                    }
                    
                    sessionParticipants.set(participant.userId, participant);
                }
                
                if (change.type === 'removed') {
                    const participant = change.doc.data();
                    console.log('âž– Participant removed:', participant.name);
                    
                    closePeerConnection(participant.userId);
                    sessionParticipants.delete(participant.userId);
                }
                
                if (change.type === 'modified') {
                    const participant = change.doc.data();
                    sessionParticipants.set(participant.userId, participant);
                    
                    // âœ… NEW: Check if coach muted/unmuted this student
                    if (participant.userId === currentUser.uid && !isCoach) {
                        const wasCoachMuted = coachMutedMe;
                        coachMutedMe = participant.coachMuted || false;
                        
                        if (coachMutedMe && !wasCoachMuted) {
                            // Coach just muted me
                            console.log('ðŸ”‡ Coach muted you');
                            if (localAudioStream) {
                                const audioTrack = localAudioStream.getAudioTracks()[0];
                                if (audioTrack) {
                                    audioTrack.enabled = false;
                                    isMicMuted = true;
                                    
                                    const btn = document.getElementById('student-toggle-mic-btn');
                                    if (btn) {
                                        btn.textContent = 'ðŸ”‡ Unmute';
                                        btn.style.background = '#dc3545';
                                    }
                                }
                            }
                            alert('ðŸ”‡ Your coach has muted you');
                        } else if (!coachMutedMe && wasCoachMuted) {
                            // Coach unmuted me
                            console.log('ðŸ”Š Coach unmuted you');
                            alert('ðŸ”Š Your coach has unmuted you. You can now speak.');
                        }
                    }
                }
            });
            
            updateParticipantsList();
        });
    
    // Listen for WebRTC signaling
    listenForSignaling();
}
        
        
// ===== CLOSE PEER CONNECTION =====
function closePeerConnection(userId) {
    const peerConnection = peerConnections.get(userId);
    if (peerConnection) {
        peerConnection.close();
        peerConnections.delete(userId);
    }
    
    // Ã¢Å“â€¦ Clear queued ICE candidates
    if (pendingIceCandidates.has(userId)) {
        console.log('ðŸ—‘ï¸ Clearing queued ICE candidates for:', userId);
        pendingIceCandidates.delete(userId);
    }
    
    const audioElement = document.getElementById(`audio_${userId}`);
    if (audioElement) {
        audioElement.pause();
        audioElement.srcObject = null;
        audioElement.remove();
    }
    
    remoteStreams.delete(userId);
}

// ===== END LIVE SESSION =====
async function endLiveSession() {
    const isCoachUser = isCoach;
    const confirmMessage = isCoachUser 
        ? 'Are you sure you want to end the live session for everyone?' 
        : 'Are you sure you want to leave the live session?';
    
    if (!confirm(confirmMessage)) {
        return;
    }
    
    try {
        console.log('ðŸ›‘ Ending live session...');
        
        // âœ… CRITICAL: Stop and remove ALL audio elements first
        document.querySelectorAll('audio').forEach(audio => {
            console.log('ðŸ—‘ï¸ Removing audio element:', audio.id);
            audio.pause();
            audio.srcObject = null;
            audio.remove();
        });
        
        // âœ… Stop local audio tracks
        if (localAudioStream) {
            console.log('ðŸ›‘ Stopping local audio stream');
            localAudioStream.getTracks().forEach(track => {
                console.log('   Stopping track:', track.kind, track.id);
                track.stop();
            });
            localAudioStream = null;
        }
        
        // âœ… Close ALL peer connections
        console.log('ðŸ›‘ Closing peer connections:', peerConnections.size);
        peerConnections.forEach((pc, userId) => {
            console.log('   Closing connection with:', userId);
            try {
                pc.close();
            } catch (e) {
                console.error('   Error closing connection:', e);
            }
        });
        peerConnections.clear();
        
        // âœ… Clear all queued ICE candidates
        pendingIceCandidates.clear();
        console.log('ðŸ—‘ï¸ Cleared all queued ICE candidates');
        
        // âœ… Clear remote streams
        remoteStreams.clear();
        
        // âœ… Unsubscribe from session listeners
        if (liveSessionListener) {
            console.log('ðŸ›‘ Unsubscribing from session listener');
            try {
                liveSessionListener();
            } catch (e) {
                console.error('Error unsubscribing:', e);
            }
            liveSessionListener = null;
        }
        
        // âœ… Remove from participants in Firestore
        const classId = myClass ? myClass.id : liveSessionId;
        if (classId && currentUser) {
            console.log('ðŸ—‘ï¸ Removing from session participants');
            await db.collection('classes')
                .doc(classId)
                .collection('sessionParticipants')
                .doc(currentUser.uid)
                .delete();
        }
        
        // âœ… If coach, end session for everyone
        if (isCoachUser && myClass) {
            console.log('ðŸ›‘ Coach ending session for everyone');
            
            await db.collection('classes').doc(myClass.id).update({
                liveSessionActive: false,
                liveSessionId: null
            });
            
            // Clear all participants
            const participantsSnapshot = await db.collection('classes')
                .doc(myClass.id)
                .collection('sessionParticipants')
                .get();
            
            const batch = db.batch();
            participantsSnapshot.forEach(doc => {
                batch.delete(doc.ref);
            });
            await batch.commit();
            
            // Clear signaling data
            console.log('ðŸ—‘ï¸ Clearing signaling data');
            const [offersSnap, answersSnap, candidatesSnap] = await Promise.all([
                db.collection('classes').doc(myClass.id).collection('offers').get(),
                db.collection('classes').doc(myClass.id).collection('answers').get(),
                db.collection('classes').doc(myClass.id).collection('iceCandidates').get()
            ]);
            
            const signalingBatch = db.batch();
            offersSnap.forEach(doc => signalingBatch.delete(doc.ref));
            answersSnap.forEach(doc => signalingBatch.delete(doc.ref));
            candidatesSnap.forEach(doc => signalingBatch.delete(doc.ref));
            await signalingBatch.commit();
        }
        
        // âœ… Clear session participants map
        sessionParticipants.clear();
        
        // âœ… Reset state variables
        liveSessionActive = false;
        liveSessionId = null;
        isMicMuted = false;
        
        // âœ… Reset UI based on user type
        if (isCoachUser) {
            const startBtn = document.getElementById('start-session-btn');
            const liveSessionContainer = document.getElementById('coach-live-session-active');
            
            if (liveSessionContainer) liveSessionContainer.style.display = 'none';
            if (startBtn) {
                startBtn.style.display = 'block';
                startBtn.textContent = 'ðŸŽ¥ Start Live Session';
                startBtn.style.background = '#28a745';
            }
            
            // Clear participants list
            const participantsList = document.getElementById('coach-session-participants-list');
            if (participantsList) participantsList.innerHTML = '<p style="color: #666;">No participants</p>';
            
        } else {
            // Student: Reload view to show correct UI
            await loadStudentClassView();
        }
        
        const message = isCoachUser ? 'âœ… Live session ended' : 'âœ… Left live session';
        alert(message);
        
        console.log('âœ… Session cleanup complete');
        
    } catch (error) {
        console.error('âŒ Error ending session:', error);
        alert('Error ending session: ' + error.message);
    }
}

// ===== CHECK FOR ACTIVE SESSION (FOR STUDENTS) =====
async function checkForActiveSession() {
    if (!currentUser) return;
    
    try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        
        if (!userData || !userData.classId || userData.userType !== 'student') return;
        
        const classDoc = await db.collection('classes').doc(userData.classId).get();
        const classData = classDoc.data();
        
        if (classData && classData.liveSessionActive) {
            // Show join button
            const studentClassInfo = document.getElementById('student-class-info');
            
            const joinBtnHtml = `
                <div style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); padding: 20px; border-radius: 10px; text-align: center; margin-top: 20px;">
                    <h3 style="color: white; margin-bottom: 15px;">ðŸŽ¥ Live Session Active!</h3>
                    <button id="join-session-btn" class="practice-btn" onclick="joinLiveSession()" style="background: white; color: #28a745; font-size: 1.2rem;">
                        Join Live Session
                    </button>
                </div>
            `;
            
            // Check if button doesn't already exist
            if (!document.getElementById('join-session-btn')) {
                studentClassInfo.insertAdjacentHTML('beforeend', joinBtnHtml);
            }
        }
    } catch (error) {
        console.error('Error checking for active session:', error);
    }
}  

    </script>
</body>
</html>

