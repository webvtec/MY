// ===== START LIVE SESSION (COACH ONLY) =====
async function startLiveSession() {
    if (!currentUser || !myClass) {
        alert('Unable to start session');
        return;
    }
    
    try {
        console.log('üé§ Starting live session...');
        
        // ‚úÖ CRITICAL: Clean up any existing session first
        if (localAudioStream) {
            console.log('‚ö†Ô∏è Cleaning up existing audio stream');
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
        
        if (peerConnections.size > 0) {
            console.log('‚ö†Ô∏è Cleaning up existing peer connections');
            peerConnections.forEach(pc => pc.close());
            peerConnections.clear();
        }
        
        if (liveSessionListener) {
            console.log('‚ö†Ô∏è Cleaning up existing listener');
            liveSessionListener();
            liveSessionListener = null;
        }
        
        // ‚úÖ CHECK IF SESSION IS ALREADY ACTIVE (REJOIN SCENARIO)
        const isRejoin = myClass.liveSessionActive && myClass.liveSessionId;
        
        // Get microphone permission with fresh stream
        console.log('üé§ Requesting microphone access...');
        localAudioStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            } 
        });
        
        // ‚úÖ START WITH MIC MUTED
        localAudioStream.getAudioTracks().forEach(track => {
            track.enabled = false; // Start muted
        });
        isMicMuted = true;
        
        console.log('‚úÖ Microphone access granted (MUTED by default)');
        
        if (!isRejoin) {
            // Starting new session
            liveSessionId = myClass.id;
            
            const currentSessionCount = myClass.sessionCount || 0;
            
            await db.collection('classes').doc(myClass.id).update({
                liveSessionActive: true,
                liveSessionId: liveSessionId,
                liveSessionStartedAt: firebase.firestore.FieldValue.serverTimestamp(),
                liveSessionHost: currentUser.uid,
                sessionCount: currentSessionCount + 1
            });
            
            console.log('‚úÖ New session started');
            myClass.sessionCount = currentSessionCount + 1;
        } else {
            // Rejoining existing session
            liveSessionId = myClass.liveSessionId;
            console.log('üîÑ Rejoining existing session:', liveSessionId);
        }
        
        // Add/update coach as participant
       await db.collection('classes')
            .doc(myClass.id)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .set({
                userId: currentUser.uid,
                name: currentUser.displayName || 'Coach',
                email: currentUser.email,
                photoURL: currentUser.photoURL || null,
                joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                micMuted: true,
                coachMuted: false,
                isCoach: true // ‚úÖ Add coach flag
            });
        
        liveSessionActive = true;
        isCoach = true;
        
        // ‚úÖ Store coach flag in participant data
        await db.collection('classes')
            .doc(myClass.id)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .update({
                isCoach: true
            });
        
        // Show live session UI for COACH
        const startBtn = document.getElementById('start-session-btn');
        const liveSessionContainer = document.getElementById('coach-live-session-active');
        
        if (startBtn) startBtn.style.display = 'none';
        if (liveSessionContainer) liveSessionContainer.style.display = 'block';
        
        // ‚úÖ Set mic button to muted state
        const micBtn = document.getElementById('coach-toggle-mic-btn');
        if (micBtn) {
            micBtn.textContent = 'üîá Unmute';
            micBtn.style.background = '#dc3545';
        }
        
        // Update session count in UI
        updateCoachClassStats();
        
        // Listen for participants joining
        listenForSessionParticipants();
        
        const message = isRejoin ? '‚úÖ Rejoined live session! (Mic is muted)' : '‚úÖ Live session started! (Mic is muted - click Unmute to speak)';
        alert(message);
        
        console.log('‚úÖ Session start complete');
        
    } catch (error) {
        console.error('‚ùå Error starting live session:', error);
        
        if (error.name === 'NotAllowedError') {
            alert('‚ùå Microphone access denied. Please allow microphone access and try again.');
        } else if (error.name === 'NotFoundError') {
            alert('‚ùå No microphone found. Please connect a microphone and try again.');
        } else {
            alert('Failed to start session: ' + error.message);
        }
        
        // Cleanup on error
        if (localAudioStream) {
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
    }
}
        
// ===== JOIN LIVE SESSION (STUDENT) =====
async function joinLiveSession() {
    if (!currentUser) {
        alert('Please sign in to join the session');
        return;
    }
    
    try {
        console.log('üé§ Joining live session...');
        
        // ‚úÖ Set cleanup flag
        isCleaningUp = true;
        
        // ‚úÖ CRITICAL: Clean up any existing session first
        if (localAudioStream) {
            console.log('‚ö†Ô∏è Cleaning up existing audio stream');
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
        
        if (peerConnections.size > 0) {
            console.log('‚ö†Ô∏è Cleaning up existing peer connections');
            peerConnections.forEach(pc => pc.close());
            peerConnections.clear();
        }
        
        if (liveSessionListener) {
            console.log('‚ö†Ô∏è Cleaning up existing listener');
            liveSessionListener();
            liveSessionListener = null;
        }
        
        // Clear pending ICE candidates
        pendingIceCandidates.clear();
        
        // Get user data
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        
        if (!userData.classId) {
            alert('You are not enrolled in a class');
            isCleaningUp = false;
            return;
        }
        
        liveSessionId = userData.classId;
        
        // Check if session is actually active
        const classDoc = await db.collection('classes').doc(userData.classId).get();
        const classData = classDoc.data();
        
        if (!classData.liveSessionActive || !classData.liveSessionId) {
            alert('‚ùå This session is no longer active');
            isCleaningUp = false;
            return;
        }
        
        console.log('‚úÖ Session is active, joining...');
        
        // ‚úÖ Check if we're already in the participants list (rejoining scenario)
        const existingParticipant = await db.collection('classes')
            .doc(userData.classId)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .get();

        if (existingParticipant.exists) {
            console.log('üîÑ Rejoining - cleaning up old participant entry and signaling');
            
            // ‚úÖ Clean up old signaling messages FIRST
            await cleanupOldSignalingMessages(currentUser.uid);
            
            // Delete old entry to force clean reconnection
            await db.collection('classes')
                .doc(userData.classId)
                .collection('sessionParticipants')
                .doc(currentUser.uid)
                .delete();
            
            // ‚úÖ Wait for coach to detect removal and clean up
            console.log('‚è≥ Waiting 5 seconds for complete cleanup...');
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // ‚úÖ Clean up signaling AGAIN (in case coach sent messages during deletion)
            await cleanupOldSignalingMessages(currentUser.uid);
        }
        
        // Get microphone permission with fresh stream
        console.log('üé§ Requesting microphone access...');
        localAudioStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            } 
        });
        
        // ‚úÖ START WITH MIC MUTED
        localAudioStream.getAudioTracks().forEach(track => {
            track.enabled = false; // Start muted
        });
        isMicMuted = true;
        
        console.log('‚úÖ Microphone access granted (MUTED by default)');
        
        // ‚úÖ Clear cleanup flag BEFORE starting listeners
        isCleaningUp = false;
        
        // Add to session participants (this triggers coach to create new connection)
        console.log('üìù Adding to session participants...');
        await db.collection('classes')
            .doc(userData.classId)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .set({
                userId: currentUser.uid,
                name: userData.name || 'Student',
                email: userData.email,
                photoURL: userData.photoURL || null,
                joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                micMuted: true,
                coachMuted: false,
                isCoach: false // ‚úÖ Add student flag
            });
        
        console.log('‚úÖ Added to session participants');
        console.log('‚úÖ Added to session participants as STUDENT (isCoach: false)');
        console.log('üîç My role - isCoach:', isCoach, 'currentUser.uid:', currentUser.uid);
        liveSessionActive = true;
        
        // Hide join button and show active session UI
        const joinContainer = document.getElementById('live-session-join-container');
        const activeSessionUI = document.getElementById('student-live-session-active');
        
        if (joinContainer) joinContainer.style.display = 'none';
        if (activeSessionUI) activeSessionUI.style.display = 'block';
        
        // ‚úÖ Set mic button to muted state
        const micBtn = document.getElementById('student-toggle-mic-btn');
        if (micBtn) {
            micBtn.textContent = 'üîá Unmute';
            micBtn.style.background = '#dc3545';
        }
        
        // Listen for participants (this will trigger coach's offer)
        listenForSessionParticipants();
        
        alert('‚úÖ Joined live session! (Mic is muted - click Unmute when ready to speak)');
        
        console.log('‚úÖ Joined live session successfully');
        
    } catch (error) {
        console.error('‚ùå Error joining session:', error);
        
        // ‚úÖ Clear cleanup flag on error
        isCleaningUp = false;
        
        let errorMessage = 'Failed to join session. ';
        
        if (error.name === 'NotAllowedError') {
            errorMessage += 'Microphone access was denied. Please allow microphone access in your browser settings and try again.';
        } else if (error.name === 'NotFoundError') {
            errorMessage += 'No microphone found. Please connect a microphone and try again.';
        } else if (error.message) {
            errorMessage += error.message;
        } else {
            errorMessage += 'Please check your microphone permissions and try again.';
        }
        
        alert(errorMessage);
        
        // Cleanup on error
        if (localAudioStream) {
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
        
        // Remove from participants if we added ourselves
        try {
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            const userData = userDoc.data();
            if (userData.classId) {
                await db.collection('classes')
                    .doc(userData.classId)
                    .collection('sessionParticipants')
                    .doc(currentUser.uid)
                    .delete();
            }
        } catch (cleanupError) {
            console.error('Error cleaning up after failed join:', cleanupError);
        }
    }
}

   
// ===== LISTEN FOR SESSION PARTICIPANTS =====
function listenForSessionParticipants() {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üëÇ Setting up participant listener for class:', classId);
    
    liveSessionListener = db.collection('classes')
        .doc(classId)
        .collection('sessionParticipants')
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const participant = change.doc.data();
                    
                    console.log('‚ûï Participant added:', participant.name, participant.userId);
                    
                    // Skip ourselves
                    if (participant.userId === currentUser.uid) {
                        console.log('   ‚è≠Ô∏è Skipping self');
                        sessionParticipants.set(participant.userId, participant);
                        return;
                    }
                    
                    // ‚úÖ EVERYONE CREATES CONNECTIONS TO EVERYONE
                    if (isCoach) {
                        // Coach initiates all connections
                        console.log('üëë Coach creating connection to:', participant.name);
                        await createPeerConnection(participant.userId, participant, true);
                    } else {
                        // Student connecting to others
                        console.log('üë• Student needs to connect to:', participant.name);
                        
                        // Check if participant is coach
                        if (participant.isCoach) {
                            console.log('   ‚Üí Participant is COACH, waiting for their offer');
                            // Coach will initiate, we wait
                        } else {
                            console.log('   ‚Üí Participant is STUDENT, checking who initiates...');
                            // Student-to-student: Compare UIDs to avoid duplicate connections
                            if (currentUser.uid < participant.userId) {
                                console.log('   ‚Üí ‚úÖ I INITIATE (my UID is lower)');
                                await createPeerConnection(participant.userId, participant, true);
                            } else {
                                console.log('   ‚Üí ‚è≥ THEY INITIATE (their UID is lower), waiting for offer');
                                // They will initiate, we wait for offer
                            }
                        }
                    }
                    
                    sessionParticipants.set(participant.userId, participant);
                }
                
                if (change.type === 'removed') {
                    const participant = change.doc.data();
                    console.log('‚ûñ Participant removed:', participant.name);
                    
                    closePeerConnection(participant.userId);
                    sessionParticipants.delete(participant.userId);
                }
                
                if (change.type === 'modified') {
                    const participant = change.doc.data();
                    sessionParticipants.set(participant.userId, participant);
                    
                    // ‚úÖ Check if coach muted/unmuted this student
                    if (participant.userId === currentUser.uid && !isCoach) {
                        const wasCoachMuted = coachMutedMe;
                        coachMutedMe = participant.coachMuted || false;
                        
                        if (coachMutedMe && !wasCoachMuted) {
                            console.log('üîá Coach muted you');
                            if (localAudioStream) {
                                const audioTrack = localAudioStream.getAudioTracks()[0];
                                if (audioTrack) {
                                    audioTrack.enabled = false;
                                    isMicMuted = true;
                                    
                                    // Update all peer connections
                                    peerConnections.forEach((pc) => {
                                        const senders = pc.getSenders();
                                        senders.forEach(sender => {
                                            if (sender.track && sender.track.kind === 'audio') {
                                                sender.track.enabled = false;
                                            }
                                        });
                                    });
                                    
                                    const btn = document.getElementById('student-toggle-mic-btn');
                                    if (btn) {
                                        btn.textContent = 'üîá Unmute';
                                        btn.style.background = '#dc3545';
                                    }
                                }
                            }
                            alert('üîá Your coach has muted you');
                        } else if (!coachMutedMe && wasCoachMuted) {
                            console.log('üîä Coach unmuted you');
                            alert('üîä Your coach has unmuted you. You can now speak.');
                        }
                    }
                }
            });
            
            updateParticipantsList();
        });
    
    // Listen for WebRTC signaling
    listenForSignaling();
}


// ===== CHECK IF USER IS COACH =====
async function checkIfUserIsCoach(userId) {
    try {
        const classId = myClass ? myClass.id : liveSessionId;
        const classDoc = await db.collection('classes').doc(classId).get();
        const classData = classDoc.data();
        
        // Check if this user is the coach of the class
        return classData && classData.coachId === userId;
    } catch (error) {
        console.error('Error checking if user is coach:', error);
        return false;
    }
}


// ===== CONNECTION HEALTH CHECK WITH AUDIO VERIFICATION =====
function startConnectionHealthCheck(userId, peerConnection, participant) {
    // Clear any existing check
    if (connectionHealthChecks.has(userId)) {
        clearInterval(connectionHealthChecks.get(userId));
    }
    
    let failureCount = 0;
    const MAX_FAILURES = 3;
    
    const checkInterval = setInterval(async () => {
        if (!peerConnection || peerConnection.connectionState === 'closed') {
            clearInterval(checkInterval);
            connectionHealthChecks.delete(userId);
            return;
        }
        
        const state = peerConnection.connectionState;
        const iceState = peerConnection.iceConnectionState;
        
        console.log(`üè• Health check ${participant.name}: connection=${state}, ice=${iceState}`);
        
        // Check for failures
        if (state === 'failed' || iceState === 'failed' || iceState === 'disconnected') {
            failureCount++;
            console.warn(`‚ö†Ô∏è Connection issue detected for ${participant.name} (${failureCount}/${MAX_FAILURES})`);
            
            if (failureCount >= MAX_FAILURES) {
                console.error(`‚ùå Connection health check failed ${MAX_FAILURES} times for ${participant.name}, reconnecting...`);
                clearInterval(checkInterval);
                connectionHealthChecks.delete(userId);
                
                // Close and recreate connection
                peerConnection.close();
                peerConnections.delete(userId);
                
                // Remove audio element
                const audioElement = document.getElementById(`audio_${userId}`);
                if (audioElement) {
                    audioElement.pause();
                    audioElement.srcObject = null;
                    audioElement.remove();
                }
                
                if (sessionParticipants.has(userId) && !isCleaningUp) {
                    setTimeout(() => {
                        console.log('üîÑ Recreating connection to:', participant.name);
                        createPeerConnection(userId, participant, isCoach);
                    }, 2000);
                }
            }
        } else if (state === 'connected' && iceState === 'connected') {
            // Connection is good, reset failure count
            if (failureCount > 0) {
                console.log(`‚úÖ Connection recovered for ${participant.name}`);
                failureCount = 0;
            }
            
            // ‚úÖ VERIFY AUDIO IS ACTUALLY FLOWING
            const audioElement = document.getElementById(`audio_${userId}`);
            if (audioElement && audioElement.srcObject) {
                const stream = audioElement.srcObject;
                const audioTracks = stream.getAudioTracks();
                
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    if (track.readyState === 'ended') {
                        console.error(`‚ùå Audio track ended for ${participant.name}, recreating connection`);
                        failureCount = MAX_FAILURES; // Force reconnection
                    }
                } else {
                    console.warn(`‚ö†Ô∏è No audio tracks for ${participant.name}`);
                }
            }
        }
    }, 5000); // Check every 5 seconds
    
    connectionHealthChecks.set(userId, checkInterval);
    console.log(`‚úÖ Health monitoring started for ${participant.name}`);
}

        
// ===== CREATE PEER CONNECTION WITH HEALTH MONITORING =====
async function createPeerConnection(userId, participant, isInitiator = true) {
    try {
        console.log('üîó Creating peer connection with:', participant.name, 'isInitiator:', isInitiator);
        
        // Stop any existing health check
        if (connectionHealthChecks.has(userId)) {
            clearInterval(connectionHealthChecks.get(userId));
            connectionHealthChecks.delete(userId);
        }
        
        // Ensure we have a local audio stream
        if (!localAudioStream || localAudioStream.getTracks().length === 0) {
            console.error('‚ùå No local audio stream available! Re-requesting...');
            try {
                localAudioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                localAudioStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMicMuted;
                });
                console.log('‚úÖ Re-acquired microphone access');
            } catch (error) {
                console.error('‚ùå Failed to re-acquire microphone:', error);
                throw error;
            }
        }
        
        // Close existing connection if it exists
        if (peerConnections.has(userId)) {
            console.log('‚ö†Ô∏è Closing existing connection before creating new one');
            const oldPc = peerConnections.get(userId);
            oldPc.close();
            peerConnections.delete(userId);
            
            const oldAudio = document.getElementById(`audio_${userId}`);
            if (oldAudio) {
                oldAudio.pause();
                oldAudio.srcObject = null;
                oldAudio.remove();
            }
        }
        
        const peerConnection = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10
        });
        
        // ‚úÖ CAPTURE CURRENT MIC STATE BEFORE ADDING TRACKS
        const currentMicState = isMicMuted;
        console.log('üì∏ Captured mic state:', currentMicState ? 'MUTED' : 'UNMUTED');
        
        // Add local audio tracks
        console.log('üé§ Adding local audio tracks to peer connection');
        localAudioStream.getTracks().forEach(track => {
            // ‚úÖ Set to ACTUAL current state, not forced
            track.enabled = !currentMicState;
            console.log('   ‚úÖ Track added:', track.kind, 'enabled:', track.enabled);
            peerConnection.addTrack(track, localAudioStream);
        });
        
        // Handle incoming tracks
        peerConnection.ontrack = (event) => {
            console.log('üì• Received track from:', participant.name);
            console.log('   Track kind:', event.track.kind);
            console.log('   Track enabled:', event.track.enabled);
            console.log('   Track readyState:', event.track.readyState);
            
            if (event.streams.length === 0) {
                console.error('‚ùå No streams in track event!');
                return;
            }
            
            const remoteStream = event.streams[0];
            console.log('   Stream audio tracks:', remoteStream.getAudioTracks().length);
            
            remoteStreams.set(userId, remoteStream);
            
            // Remove old audio element if exists
            const oldAudio = document.getElementById(`audio_${userId}`);
            if (oldAudio) {
                console.log('üóëÔ∏è Removing old audio element');
                oldAudio.pause();
                oldAudio.srcObject = null;
                oldAudio.remove();
            }
            
            // Create new audio element
            setTimeout(() => {
                const audioElement = document.createElement('audio');
                audioElement.id = `audio_${userId}`;
                audioElement.autoplay = true;
                audioElement.playsInline = true;
                audioElement.volume = 1.0;
                audioElement.srcObject = remoteStream;
                
                audioElement.onloadedmetadata = () => {
                    console.log('‚úÖ Audio metadata loaded for:', participant.name);
                };
                
                audioElement.onplay = () => {
                    console.log('‚úÖ Audio started playing for:', participant.name);
                };
                
                audioElement.onerror = (e) => {
                    console.error('‚ùå Audio element error:', e);
                };
                
                let container = document.getElementById('remote-audio-container');
                if (!container) {
                    console.warn('‚ö†Ô∏è remote-audio-container not found, creating it');
                    container = document.createElement('div');
                    container.id = 'remote-audio-container';
                    container.style.display = 'none';
                    document.body.appendChild(container);
                }
                container.appendChild(audioElement);
                
                console.log('‚úÖ Audio element created and added');
                
                // Force play
                const playPromise = audioElement.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('‚úÖ Audio playing successfully for:', participant.name);
                        })
                        .catch(err => {
                            console.error('‚ùå Error playing audio:', err);
                            if (err.name === 'NotAllowedError') {
                                alert(`Click OK to enable audio from ${participant.name}`);
                                audioElement.play()
                                    .then(() => console.log('‚úÖ Audio playing after user interaction'))
                                    .catch(e => console.error('‚ùå Still failed:', e));
                            }
                        });
                }
            }, 100);
        };
        
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('üßä Sending ICE candidate to:', participant.name);
                sendIceCandidate(userId, event.candidate);
            }
        };
        
        peerConnection.onconnectionstatechange = () => {
            console.log(`Connection state with ${participant.name}:`, peerConnection.connectionState);
            
            if (peerConnection.connectionState === 'connected') {
                console.log('‚úÖ Peer connection established with:', participant.name);
                
                // ‚úÖ START HEALTH MONITORING
                startConnectionHealthCheck(userId, peerConnection, participant);
                
            } else if (peerConnection.connectionState === 'failed') {
                console.error('‚ùå Connection failed with:', participant.name);
                
                // Stop health check
                if (connectionHealthChecks.has(userId)) {
                    clearInterval(connectionHealthChecks.get(userId));
                    connectionHealthChecks.delete(userId);
                }
                
                // Attempt reconnection after delay
                setTimeout(() => {
                    if (sessionParticipants.has(userId)) {
                        console.log('üîÑ Attempting to reconnect with:', participant.name);
                        createPeerConnection(userId, participant, isCoach);
                    }
                }, 3000);
                
            } else if (peerConnection.connectionState === 'disconnected') {
                console.warn('‚ö†Ô∏è Connection disconnected with:', participant.name);
            }
        };
        
        peerConnection.oniceconnectionstatechange = () => {
            console.log(`ICE connection state with ${participant.name}:`, peerConnection.iceConnectionState);
            
            if (peerConnection.iceConnectionState === 'failed') {
                console.error('‚ùå ICE connection failed, triggering restart');
                peerConnection.restartIce();
            }
        };
        
        peerConnections.set(userId, peerConnection);
        
        if (isInitiator) {
            console.log('üì§ Creating and sending offer to:', participant.name);
            const offer = await peerConnection.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: false
            });
            await peerConnection.setLocalDescription(offer);
            await sendOffer(userId, offer);
            console.log('‚úÖ Offer sent to:', participant.name);
        }
        
        return peerConnection;
        
    } catch (error) {
        console.error('‚ùå Error creating peer connection:', error);
        throw error;
    }
}

    
        
// ===== HANDLE OFFER =====
async function handleOffer(fromUserId, offer) {
    try {
        console.log('üì® Handling offer from user:', fromUserId);
        
        // ‚úÖ Check if we're already trying to connect to this user
        if (peerConnections.has(fromUserId)) {
            const existingPc = peerConnections.get(fromUserId);
            
            // If we're in a negotiation state, let the lower UID win
            if (existingPc.signalingState !== 'stable') {
                console.log('‚ö†Ô∏è Simultaneous connection attempt detected');
                
                // Compare UIDs - lower UID's offer wins
                if (currentUser.uid < fromUserId) {
                    console.log('   ‚Üí My UID is lower, ignoring their offer (I already sent mine)');
                    return;
                } else {
                    console.log('   ‚Üí Their UID is lower, accepting their offer and closing mine');
                    existingPc.close();
                    peerConnections.delete(fromUserId);
                    
                    const oldAudio = document.getElementById(`audio_${fromUserId}`);
                    if (oldAudio) {
                        oldAudio.pause();
                        oldAudio.srcObject = null;
                        oldAudio.remove();
                    }
                }
            }
        }
        
        // Ensure we have a local audio stream
        if (!localAudioStream || localAudioStream.getTracks().length === 0) {
            console.error('‚ùå No local audio stream! Re-requesting...');
            try {
                localAudioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                localAudioStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMicMuted;
                });
                console.log('‚úÖ Re-acquired microphone for handling offer');
            } catch (error) {
                console.error('‚ùå Failed to re-acquire microphone:', error);
                throw error;
            }
        }
        
        // Close any existing connection first
        let peerConnection = peerConnections.get(fromUserId);
        if (peerConnection) {
            console.log('‚ö†Ô∏è Closing existing connection before handling offer');
            peerConnection.close();
            peerConnections.delete(fromUserId);
            
            const oldAudio = document.getElementById(`audio_${fromUserId}`);
            if (oldAudio) {
                oldAudio.pause();
                oldAudio.srcObject = null;
                oldAudio.remove();
            }
        }
        
        if (pendingIceCandidates.has(fromUserId)) {
            console.log('üóëÔ∏è Clearing old queued ICE candidates');
            pendingIceCandidates.delete(fromUserId);
        }
        
        // Get participant info
        const classId = myClass ? myClass.id : liveSessionId;
        const participantDoc = await db.collection('classes')
            .doc(classId)
            .collection('sessionParticipants')
            .doc(fromUserId)
            .get();
        
        if (!participantDoc.exists) {
            console.error('‚ùå Participant not found:', fromUserId);
            return;
        }
        
        const participant = participantDoc.data();
        console.log('üë§ Creating connection for:', participant.name);
        
        // Create new peer connection
        peerConnection = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10
        });
        
        // ‚úÖ CAPTURE CURRENT MIC STATE BEFORE ADDING TRACKS
        const currentMicState = isMicMuted;
        console.log('üì∏ Captured mic state for answer:', currentMicState ? 'MUTED' : 'UNMUTED');
        
        // Add local audio tracks
        console.log('üé§ Adding local audio tracks (answering)');
        localAudioStream.getTracks().forEach(track => {
            // ‚úÖ Set to ACTUAL current state
            track.enabled = !currentMicState;
            console.log('   ‚úÖ Track added:', track.kind, 'enabled:', track.enabled);
            peerConnection.addTrack(track, localAudioStream);
        });
        
        // Handle remote audio
        peerConnection.ontrack = (event) => {
            console.log('üì• Received track from:', participant.name);
            console.log('   Track kind:', event.track.kind);
            console.log('   Track enabled:', event.track.enabled);
            console.log('   Track readyState:', event.track.readyState);
            
            if (event.streams.length === 0) {
                console.error('‚ùå No streams!');
                return;
            }
            
            const remoteStream = event.streams[0];
            console.log('   Stream audio tracks:', remoteStream.getAudioTracks().length);
            remoteStreams.set(fromUserId, remoteStream);
            
            let audioElement = document.getElementById(`audio_${fromUserId}`);
            if (audioElement) {
                console.log('üóëÔ∏è Removing old audio element');
                audioElement.pause();
                audioElement.srcObject = null;
                audioElement.remove();
            }
            
            setTimeout(() => {
                audioElement = document.createElement('audio');
                audioElement.id = `audio_${fromUserId}`;
                audioElement.autoplay = true;
                audioElement.playsInline = true;
                audioElement.volume = 1.0;
                audioElement.srcObject = remoteStream;
                
                audioElement.onloadedmetadata = () => {
                    console.log('‚úÖ Audio metadata loaded for:', participant.name);
                };
                
                audioElement.onplay = () => {
                    console.log('‚úÖ Audio started playing for:', participant.name);
                };
                
                audioElement.onerror = (e) => {
                    console.error('‚ùå Audio element error:', e);
                };
                
                let container = document.getElementById('remote-audio-container');
                if (!container) {
                    console.warn('‚ö†Ô∏è Container not found, creating it');
                    container = document.createElement('div');
                    container.id = 'remote-audio-container';
                    container.style.display = 'none';
                    document.body.appendChild(container);
                }
                container.appendChild(audioElement);
                
                const playPromise = audioElement.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => console.log('‚úÖ Audio playing from:', participant.name))
                        .catch(err => {
                            console.error('‚ùå Playback error:', err);
                            if (err.name === 'NotAllowedError') {
                                alert(`Click OK to enable audio from ${participant.name}`);
                                audioElement.play();
                            }
                        });
                }
            }, 100);
        };
        
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('üßä Sending ICE candidate');
                sendIceCandidate(fromUserId, event.candidate);
            }
        };
        
        peerConnection.onconnectionstatechange = () => {
            console.log(`Connection state with ${participant.name}:`, peerConnection.connectionState);
            
            if (peerConnection.connectionState === 'connected') {
                console.log('‚úÖ Peer connection established with:', participant.name);
                
                // ‚úÖ START HEALTH MONITORING
                startConnectionHealthCheck(fromUserId, peerConnection, participant);
                
            } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                console.warn(`‚ö†Ô∏è Connection ${peerConnection.connectionState} with ${participant.name}`);
                
                // Stop health check
                if (connectionHealthChecks.has(fromUserId)) {
                    clearInterval(connectionHealthChecks.get(fromUserId));
                    connectionHealthChecks.delete(fromUserId);
                }
            }
        };
        
        peerConnection.oniceconnectionstatechange = () => {
            console.log(`ICE connection state with ${participant.name}:`, peerConnection.iceConnectionState);
            if (peerConnection.iceConnectionState === 'failed') {
                peerConnection.restartIce();
            }
        };
        
        peerConnections.set(fromUserId, peerConnection);
        
        // Set remote description (the offer)
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        console.log('‚úÖ Remote description set');
        
        // Create and send answer
        const answer = await peerConnection.createAnswer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: false
        });
        await peerConnection.setLocalDescription(answer);
        
        await sendAnswer(fromUserId, answer);
        console.log('‚úÖ Answer sent to:', participant.name);
        
        // Process any queued ICE candidates
        if (pendingIceCandidates.has(fromUserId)) {
            const queued = pendingIceCandidates.get(fromUserId);
            console.log(`üìã Processing ${queued.length} queued ICE candidates after offer`);
            
            for (const candidate of queued) {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log('‚úÖ Queued ICE candidate added');
                } catch (err) {
                    console.error('‚ùå Error adding queued candidate:', err);
                }
            }
            
            pendingIceCandidates.delete(fromUserId);
        }
        
    } catch (error) {
        console.error('‚ùå Error handling offer:', error);
    }
}
        
// ===== HANDLE ANSWER =====
async function handleAnswer(fromUserId, answer) {
    try {
        console.log('üì® Handling answer from user:', fromUserId);
        
        const peerConnection = peerConnections.get(fromUserId);
        
        if (!peerConnection) {
            console.warn('‚ö†Ô∏è No peer connection found for:', fromUserId, '- ignoring answer');
            return;
        }
        
        const currentState = peerConnection.signalingState;
        console.log('   Current signaling state:', currentState);
        
        // ‚úÖ Only process answer if we're waiting for one
        if (currentState === 'have-local-offer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            console.log('‚úÖ Answer processed from:', fromUserId);
            
            // ‚úÖ Process any queued ICE candidates now that remote description is set
            if (pendingIceCandidates.has(fromUserId)) {
                const queued = pendingIceCandidates.get(fromUserId);
                console.log(`üìã Processing ${queued.length} queued ICE candidates after answer`);
                
                for (const candidate of queued) {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log('‚úÖ Queued ICE candidate added');
                    } catch (err) {
                        console.error('‚ùå Error adding queued candidate:', err);
                    }
                }
                
                pendingIceCandidates.delete(fromUserId);
            }
        } else if (currentState === 'stable') {
            console.log('‚ö†Ô∏è Already in stable state - ignoring duplicate/stale answer');
        } else if (currentState === 'have-remote-offer') {
            console.warn('‚ö†Ô∏è Wrong role - we should be answering, not receiving answer. Ignoring.');
        } else {
            console.warn('‚ö†Ô∏è Unexpected signaling state:', currentState, '- ignoring answer');
        }
        
    } catch (error) {
        // ‚úÖ Catch and log without crashing
        console.error('‚ùå Error handling answer (non-fatal):', error.message);
    }
}
        
async function getParticipantData(userId) {
    const classId = myClass ? myClass.id : liveSessionId;
    const participantDoc = await db.collection('classes')
        .doc(classId)
        .collection('sessionParticipants')
        .doc(userId)
        .get();
    
    if (participantDoc.exists) {
        return participantDoc.data();
    }
    return { userId, name: 'Unknown', email: '' };
}


// ===== CLEANUP OLD SIGNALING MESSAGES =====
async function cleanupOldSignalingMessages(userId) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üóëÔ∏è Cleaning up ALL signaling messages for user:', userId);
    
    try {
        // ‚úÖ Delete ALL signaling messages in both directions
        const deletions = [];
        
        // Offers
        const offersFrom = await db.collection('classes').doc(classId).collection('offers').where('from', '==', userId).get();
        const offersTo = await db.collection('classes').doc(classId).collection('offers').where('to', '==', userId).get();
        offersFrom.forEach(doc => deletions.push(doc.ref.delete()));
        offersTo.forEach(doc => deletions.push(doc.ref.delete()));
        
        // Answers
        const answersFrom = await db.collection('classes').doc(classId).collection('answers').where('from', '==', userId).get();
        const answersTo = await db.collection('classes').doc(classId).collection('answers').where('to', '==', userId).get();
        answersFrom.forEach(doc => deletions.push(doc.ref.delete()));
        answersTo.forEach(doc => deletions.push(doc.ref.delete()));
        
        // ICE Candidates
        const candidatesFrom = await db.collection('classes').doc(classId).collection('iceCandidates').where('from', '==', userId).get();
        const candidatesTo = await db.collection('classes').doc(classId).collection('iceCandidates').where('to', '==', userId).get();
        candidatesFrom.forEach(doc => deletions.push(doc.ref.delete()));
        candidatesTo.forEach(doc => deletions.push(doc.ref.delete()));
        
        // Wait for all deletions to complete
        await Promise.all(deletions);
        
        console.log(`‚úÖ Deleted ${deletions.length} old signaling messages for ${userId}`);
        
    } catch (error) {
        console.error('Error cleaning up signaling:', error);
    }
}

        
// ===== WEBRTC SIGNALING =====
function listenForSignaling() {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üëÇ Setting up signaling listeners for class:', classId);
    
    // Listen for offers
    db.collection('classes')
        .doc(classId)
        .collection('offers')
        .where('to', '==', currentUser.uid)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    
                    // ‚úÖ Delete IMMEDIATELY before processing
                    const docRef = change.doc.ref;
                    docRef.delete().catch(e => console.error('Error deleting offer:', e));
                    
                    // ‚úÖ Ignore if we're cleaning up
                    if (isCleaningUp) {
                        console.log('‚è∏Ô∏è Ignoring offer during cleanup');
                        return;
                    }
                    
                    console.log('üì® Received offer from:', data.from);
                    await handleOffer(data.from, data.offer);
                }
            });
        });
    
    // Listen for answers
    db.collection('classes')
        .doc(classId)
        .collection('answers')
        .where('to', '==', currentUser.uid)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    const fromUserId = data.from;
                    
                    // ‚úÖ DELETE IMMEDIATELY FIRST
                    const docRef = change.doc.ref;
                    docRef.delete().catch(e => console.error('Error deleting answer:', e));
                    
                    // ‚úÖ Ignore if we're cleaning up
                    if (isCleaningUp) {
                        console.log('‚è∏Ô∏è Ignoring answer during cleanup');
                        return;
                    }
                    
                    // ‚úÖ CHECK STATE BEFORE CALLING handleAnswer
                    const peerConnection = peerConnections.get(fromUserId);
                    if (!peerConnection) {
                        console.warn('‚ö†Ô∏è No peer connection for answer from:', fromUserId);
                        return;
                    }
                    
                    if (peerConnection.signalingState !== 'have-local-offer') {
                        console.log('‚è≠Ô∏è Ignoring answer - wrong state:', peerConnection.signalingState);
                        return;
                    }
                    
                    console.log('üì® Processing answer from:', fromUserId);
                    await handleAnswer(fromUserId, data.answer);
                }
            });
        });
    
    // Listen for ICE candidates
    db.collection('classes')
        .doc(classId)
        .collection('iceCandidates')
        .where('to', '==', currentUser.uid)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    
                    // ‚úÖ Delete immediately
                    const docRef = change.doc.ref;
                    docRef.delete().catch(e => console.error('Error deleting candidate:', e));
                    
                    // ‚úÖ Ignore if we're cleaning up
                    if (isCleaningUp) {
                        console.log('‚è∏Ô∏è Ignoring ICE candidate during cleanup');
                        return;
                    }
                    
                    console.log('üì® Received ICE candidate from:', data.from);
                    await handleIceCandidate(data.from, data.candidate);
                }
            });
        });
}
        
// ===== SEND OFFER =====
async function sendOffer(toUserId, offer) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üì§ Sending offer to:', toUserId);
    
    await db.collection('classes')
        .doc(classId)
        .collection('offers')
        .add({
            from: currentUser.uid,
            to: toUserId,
            offer: {
                type: offer.type,
                sdp: offer.sdp
            },
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
}


// ===== SEND ANSWER =====
async function sendAnswer(toUserId, answer) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üì§ Sending answer to:', toUserId);
    
    await db.collection('classes')
        .doc(classId)
        .collection('answers')
        .add({
            from: currentUser.uid,
            to: toUserId,
            answer: {
                type: answer.type,
                sdp: answer.sdp
            },
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
}
        

// ===== SEND ICE CANDIDATE =====
async function sendIceCandidate(toUserId, candidate) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    await db.collection('classes')
        .doc(classId)
        .collection('iceCandidates')
        .add({
            from: currentUser.uid,
            to: toUserId,
            candidate: candidate.toJSON(),
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
}


// ===== HANDLE ICE CANDIDATE =====
async function handleIceCandidate(fromUserId, candidate) {
    try {
        const peerConnection = peerConnections.get(fromUserId);
        
        if (!peerConnection) {
            console.warn('‚ö†Ô∏è No peer connection found for:', fromUserId, '- ignoring ICE candidate');
            return;
        }
        
        // √¢≈ì‚Ä¶ Check if remote description is set
        if (peerConnection.remoteDescription && peerConnection.remoteDescription.type) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            console.log('‚úÖ ICE candidate added from:', fromUserId);
            
            // √¢≈ì‚Ä¶ Process any queued candidates
            if (pendingIceCandidates.has(fromUserId)) {
                const queued = pendingIceCandidates.get(fromUserId);
                console.log(`üìã Processing ${queued.length} queued ICE candidates`);
                
                for (const queuedCandidate of queued) {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(queuedCandidate));
                        console.log('‚úÖ Queued ICE candidate added');
                    } catch (err) {
                        console.error('‚ùå Error adding queued candidate:', err);
                    }
                }
                
                pendingIceCandidates.delete(fromUserId);
            }
        } else {
            // √¢≈ì‚Ä¶ Queue the candidate for later
            console.log('üì• Queueing ICE candidate (remote description not ready)');
            if (!pendingIceCandidates.has(fromUserId)) {
                pendingIceCandidates.set(fromUserId, []);
            }
            pendingIceCandidates.get(fromUserId).push(candidate);
        }
    } catch (error) {
        console.error('‚ùå Error handling ICE candidate:', error);
    }
}
// ===== TOGGLE MICROPHONE WITH SPEAKER LIMIT =====
async function toggleMicrophone() {
    if (!localAudioStream) {
        console.error('‚ùå No local audio stream to toggle!');
        return;
    }
    
    const audioTrack = localAudioStream.getAudioTracks()[0];
    if (!audioTrack) {
        console.error('‚ùå No audio track found!');
        return;
    }
    
    // Check if coach has muted this student
    if (coachMutedMe && isMicMuted) {
        alert('üîá Your coach has muted you. You cannot unmute yourself until the coach allows it.');
        return;
    }
    
    const classId = myClass ? myClass.id : liveSessionId;
    
    // If trying to unmute, check speaker limit
    if (isMicMuted && !isCoach) {
        // Count current active speakers (excluding self)
        const participantsSnapshot = await db.collection('classes')
            .doc(classId)
            .collection('sessionParticipants')
            .get();
        
        let activeCount = 0;
        participantsSnapshot.forEach(doc => {
            const data = doc.data();
            if (!data.micMuted && data.userId !== currentUser.uid) {
                activeCount++;
            }
        });
        
        if (activeCount >= MAX_ACTIVE_SPEAKERS) {
            alert(`‚ö†Ô∏è Maximum ${MAX_ACTIVE_SPEAKERS} speakers allowed at once. Please wait for someone to mute before unmuting.`);
            return;
        }
    }
    
    // Toggle the track
    audioTrack.enabled = !audioTrack.enabled;
    isMicMuted = !audioTrack.enabled;
    
    console.log('üé§ Microphone', isMicMuted ? 'MUTED' : 'UNMUTED', '- enabled:', audioTrack.enabled);
    
    // ‚úÖ UPDATE ALL PEER CONNECTION SENDERS
    peerConnections.forEach((pc, userId) => {
        const senders = pc.getSenders();
        senders.forEach(sender => {
            if (sender.track && sender.track.kind === 'audio') {
                sender.track.enabled = audioTrack.enabled;
                console.log(`   Updated audio sender for ${userId}: enabled=${audioTrack.enabled}`);
            }
        });
    });
    
    // Update activeSpeakers set
    if (isMicMuted) {
        activeSpeakers.delete(currentUser.uid);
    } else {
        activeSpeakers.add(currentUser.uid);
    }
    
    // Update button based on user type
    const btnId = isCoach ? 'coach-toggle-mic-btn' : 'student-toggle-mic-btn';
    const btn = document.getElementById(btnId);
    
    if (btn) {
        if (isMicMuted) {
            btn.textContent = 'üîá Unmute';
            btn.style.background = '#dc3545';
        } else {
            btn.textContent = 'üé§ Mute';
            btn.style.background = '#28a745';
        }
    }
    
    // Update in Firestore
    if (classId) {
        try {
            await db.collection('classes')
                .doc(classId)
                .collection('sessionParticipants')
                .doc(currentUser.uid)
                .update({ 
                    micMuted: isMicMuted,
                    lastMicUpdate: firebase.firestore.FieldValue.serverTimestamp()
                });
        } catch (error) {
            console.error('Error updating mic status in Firestore:', error);
        }
    }
}

        
  // ===== MUTE PARTICIPANT (COACH ONLY) =====
async function muteParticipant(userId, participantName) {
    if (!isCoach) {
        alert('Only coaches can mute participants');
        return;
    }
    
    if (!confirm(`MUTE ${participantName}?\n\nNote: Only the student can unmute themselves.`)) {
        return;
    }
    
    try {
        const classId = myClass.id;
        
        // Update in Firestore - force mute
        await db.collection('classes')
            .doc(classId)
            .collection('sessionParticipants')
            .doc(userId)
            .update({ 
                micMuted: true,
                coachMuted: true // Track that coach did this
            });
        
        console.log(`‚úÖ Muted ${participantName}`);
        
        // Update local map
        const participant = sessionParticipants.get(userId);
        if (participant) {
            participant.micMuted = true;
            participant.coachMuted = true;
            sessionParticipants.set(userId, participant);
        }
        
        // Update UI
        updateParticipantsList();
        
    } catch (error) {
        console.error('Error muting participant:', error);
        alert('Failed to mute participant: ' + error.message);
    }
}
        
// ===== UPDATE PARTICIPANTS LIST =====
function updateParticipantsList() {
    const containerId = isCoach ? 'coach-session-participants-list' : 'student-session-participants-list';
    const container = document.getElementById(containerId);
    
    if (!container) {
        console.error('Participants container not found:', containerId);
        return;
    }
    
    if (sessionParticipants.size === 0) {
        container.innerHTML = '<p style="color: #666;">No participants yet</p>';
        return;
    }
    
    // Count active speakers
    let activeSpeakerCount = 0;
    sessionParticipants.forEach(p => {
        if (!p.micMuted) activeSpeakerCount++;
    });
    
    // Update participant count for coach
    if (isCoach) {
        const countEl = document.getElementById('participant-count');
        if (countEl) countEl.textContent = sessionParticipants.size;
    }
    
    // Add speaker limit warning
    const speakerWarning = activeSpeakerCount >= MAX_ACTIVE_SPEAKERS 
        ? `<div style="background: #fff3cd; color: #856404; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-weight: bold;">
            ‚ö†Ô∏è Maximum speakers reached (${activeSpeakerCount}/${MAX_ACTIVE_SPEAKERS})
           </div>`
        : `<div style="background: #d4edda; color: #155724; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
            üé§ Active speakers: ${activeSpeakerCount}/${MAX_ACTIVE_SPEAKERS}
           </div>`;
    
    container.innerHTML = speakerWarning + Array.from(sessionParticipants.values())
        .map(participant => {
            const avatarHtml = participant.photoURL 
                ? `<div class="coach-avatar" style="width: 40px; height: 40px; background-image: url('${participant.photoURL}'); background-size: cover;"></div>`
                : `<div class="coach-avatar" style="width: 40px; height: 40px;">${(participant.name || 'U').charAt(0).toUpperCase()}</div>`;
            
            const micStatus = participant.micMuted ? 'üîá' : 'üé§';
            const isCurrentUser = participant.userId === currentUser.uid;
            
            // Coach can ONLY mute (not unmute) other participants
            const coachControls = isCoach && !isCurrentUser ? `
                <button 
                    onclick="muteParticipant('${participant.userId}', '${participant.name.replace(/'/g, "\\'")}')"
                    style="
                        background: #dc3545;
                        color: white;
                        border: none;
                        padding: 8px 15px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 0.9rem;
                        font-weight: bold;
                        transition: all 0.3s;
                    "
                    onmouseover="this.style.opacity='0.8'"
                    onmouseout="this.style.opacity='1'"
                >
                    üîá Mute
                </button>
            ` : '';
            
            // Show if coach has muted them
            const coachMutedLabel = participant.coachMuted ? 
                '<span style="color: #dc3545; font-size: 0.8rem; font-weight: bold;">(Coach Muted)</span>' : '';
            
            return `
                <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: white; border-radius: 8px; margin-bottom: 10px;">
                    ${avatarHtml}
                    <div style="flex: 1;">
                        <div style="font-weight: bold; color: #0d3b66;">
                            ${participant.name}${isCurrentUser ? ' (You)' : ''}
                            ${coachMutedLabel}
                        </div>
                        <div style="font-size: 0.9rem; color: #666;">${participant.email}</div>
                    </div>
                    <div style="font-size: 1.5rem;">${micStatus}</div>
                    ${coachControls}
                </div>
            `;
        }).join('');
}

    
function listenForSessionParticipants() {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üëÇ Setting up participant listener for class:', classId);
    
    liveSessionListener = db.collection('classes')
        .doc(classId)
        .collection('sessionParticipants')
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(change => {
                if (change.type === 'added') {
                    const participant = change.doc.data();
                    
                    console.log('‚ûï Participant added:', participant.name, participant.userId);
                    
                    if (participant.userId !== currentUser.uid) {
                        if (isCoach) {
                            console.log('üëë Coach creating connection to:', participant.name);
                            createPeerConnection(participant.userId, participant, true);
                        } else {
                            console.log('üë®‚Äçüéì Student waiting for offer from coach');
                        }
                    }
                    
                    sessionParticipants.set(participant.userId, participant);
                }
                
                if (change.type === 'removed') {
                    const participant = change.doc.data();
                    console.log('‚ûñ Participant removed:', participant.name);
                    
                    closePeerConnection(participant.userId);
                    sessionParticipants.delete(participant.userId);
                }
                
                if (change.type === 'modified') {
                    const participant = change.doc.data();
                    sessionParticipants.set(participant.userId, participant);
                    
                    // ‚úÖ NEW: Check if coach muted/unmuted this student
                    if (participant.userId === currentUser.uid && !isCoach) {
                        const wasCoachMuted = coachMutedMe;
                        coachMutedMe = participant.coachMuted || false;
                        
                        if (coachMutedMe && !wasCoachMuted) {
                            // Coach just muted me
                            console.log('üîá Coach muted you');
                            if (localAudioStream) {
                                const audioTrack = localAudioStream.getAudioTracks()[0];
                                if (audioTrack) {
                                    audioTrack.enabled = false;
                                    isMicMuted = true;
                                    
                                    const btn = document.getElementById('student-toggle-mic-btn');
                                    if (btn) {
                                        btn.textContent = 'üîá Unmute';
                                        btn.style.background = '#dc3545';
                                    }
                                }
                            }
                            alert('üîá Your coach has muted you');
                        } else if (!coachMutedMe && wasCoachMuted) {
                            // Coach unmuted me
                            console.log('üîä Coach unmuted you');
                            alert('üîä Your coach has unmuted you. You can now speak.');
                        }
                    }
                }
            });
            
            updateParticipantsList();
        });
    
    // Listen for WebRTC signaling
    listenForSignaling();
}
        
        
// ===== CLOSE PEER CONNECTION =====
function closePeerConnection(userId) {
    const peerConnection = peerConnections.get(userId);
    if (peerConnection) {
        peerConnection.close();
        peerConnections.delete(userId);
    }
    
    // √¢≈ì‚Ä¶ Clear queued ICE candidates
    if (pendingIceCandidates.has(userId)) {
        console.log('üóëÔ∏è Clearing queued ICE candidates for:', userId);
        pendingIceCandidates.delete(userId);
    }
    
    const audioElement = document.getElementById(`audio_${userId}`);
    if (audioElement) {
        audioElement.pause();
        audioElement.srcObject = null;
        audioElement.remove();
    }
    
    remoteStreams.delete(userId);
}

// ===== END LIVE SESSION =====
async function endLiveSession() {
    const isCoachUser = isCoach;
    const confirmMessage = isCoachUser 
        ? 'Are you sure you want to end the live session for everyone?' 
        : 'Are you sure you want to leave the live session?';
    
    if (!confirm(confirmMessage)) {
        return;
    }
    
    try {
        console.log('üõë Ending live session...');
        
        // Stop all health checks
        connectionHealthChecks.forEach(intervalId => clearInterval(intervalId));
        connectionHealthChecks.clear();
        
        // Stop and remove ALL audio elements first
        document.querySelectorAll('audio').forEach(audio => {
            console.log('üóëÔ∏è Removing audio element:', audio.id);
            audio.pause();
            audio.srcObject = null;
            audio.remove();
        });
        
        // Stop local audio tracks
        if (localAudioStream) {
            console.log('üõë Stopping local audio stream');
            localAudioStream.getTracks().forEach(track => {
                console.log('   Stopping track:', track.kind, track.id);
                track.stop();
            });
            localAudioStream = null;
        }
        
        // Close ALL peer connections
        console.log('üõë Closing peer connections:', peerConnections.size);
        peerConnections.forEach((pc, userId) => {
            console.log('   Closing connection with:', userId);
            try {
                pc.close();
            } catch (e) {
                console.error('   Error closing connection:', e);
            }
        });
        peerConnections.clear();
        
        // Clear all queued ICE candidates
        pendingIceCandidates.clear();
        console.log('üóëÔ∏è Cleared all queued ICE candidates');
        
        // Clear remote streams
        remoteStreams.clear();
        
        // Clear active speakers
        activeSpeakers.clear();
        
        // Unsubscribe from session listeners
        if (liveSessionListener) {
            console.log('üõë Unsubscribing from session listener');
            try {
                liveSessionListener();
            } catch (e) {
                console.error('Error unsubscribing:', e);
            }
            liveSessionListener = null;
        }
        
        // Remove from participants in Firestore
        const classId = myClass ? myClass.id : liveSessionId;
        if (classId && currentUser) {
            console.log('üóëÔ∏è Removing from session participants');
            await db.collection('classes')
                .doc(classId)
                .collection('sessionParticipants')
                .doc(currentUser.uid)
                .delete();
        }
        
        // If coach, end session for everyone
        if (isCoachUser && myClass) {
            console.log('üõë Coach ending session for everyone');
            
            await db.collection('classes').doc(myClass.id).update({
                liveSessionActive: false,
                liveSessionId: null
            });
            
            // Clear all participants
            const participantsSnapshot = await db.collection('classes')
                .doc(myClass.id)
                .collection('sessionParticipants')
                .get();
            
            const batch = db.batch();
            participantsSnapshot.forEach(doc => {
                batch.delete(doc.ref);
            });
            await batch.commit();
            
            // Clear signaling data
            console.log('üóëÔ∏è Clearing signaling data');
            const [offersSnap, answersSnap, candidatesSnap] = await Promise.all([
                db.collection('classes').doc(myClass.id).collection('offers').get(),
                db.collection('classes').doc(myClass.id).collection('answers').get(),
                db.collection('classes').doc(myClass.id).collection('iceCandidates').get()
            ]);
            
            const signalingBatch = db.batch();
            offersSnap.forEach(doc => signalingBatch.delete(doc.ref));
            answersSnap.forEach(doc => signalingBatch.delete(doc.ref));
            candidatesSnap.forEach(doc => signalingBatch.delete(doc.ref));
            await signalingBatch.commit();
        }
        
        // Clear session participants map
        sessionParticipants.clear();
        
        // Reset state variables
        liveSessionActive = false;
        liveSessionId = null;
        isMicMuted = false;
        
        // Reset UI based on user type
        if (isCoachUser) {
            const startBtn = document.getElementById('start-session-btn');
            const liveSessionContainer = document.getElementById('coach-live-session-active');
            
            if (liveSessionContainer) liveSessionContainer.style.display = 'none';
            if (startBtn) {
                startBtn.style.display = 'block';
                startBtn.textContent = 'üé• Start Live Session';
                startBtn.style.background = '#28a745';
            }
            
            // Clear participants list
            const participantsList = document.getElementById('coach-session-participants-list');
            if (participantsList) participantsList.innerHTML = '<p style="color: #666;">No participants</p>';
            
        } else {
            // Student: Reload view to show correct UI
            await loadStudentClassView();
        }
        
        const message = isCoachUser ? '‚úÖ Live session ended' : '‚úÖ Left live session';
        alert(message);
        
        console.log('‚úÖ Session cleanup complete');
        
    } catch (error) {
        console.error('‚ùå Error ending session:', error);
        alert('Error ending session: ' + error.message);
    }
}

// ===== CHECK FOR ACTIVE SESSION (FOR STUDENTS) =====
async function checkForActiveSession() {
    if (!currentUser) return;
    
    try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        
        if (!userData || !userData.classId || userData.userType !== 'student') return;
        
        const classDoc = await db.collection('classes').doc(userData.classId).get();
        const classData = classDoc.data();
        
        if (classData && classData.liveSessionActive) {
            // Show join button
            const studentClassInfo = document.getElementById('student-class-info');
            
            const joinBtnHtml = `
                <div style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); padding: 20px; border-radius: 10px; text-align: center; margin-top: 20px;">
                    <h3 style="color: white; margin-bottom: 15px;">üé• Live Session Active!</h3>
                    <button id="join-session-btn" class="practice-btn" onclick="joinLiveSession()" style="background: white; color: #28a745; font-size: 1.2rem;">
                        Join Live Session
                    </button>
                </div>
            `;
            
            // Check if button doesn't already exist
            if (!document.getElementById('join-session-btn')) {
                studentClassInfo.insertAdjacentHTML('beforeend', joinBtnHtml);
            }
        }
    } catch (error) {
        console.error('Error checking for active session:', error);
    }
}  
