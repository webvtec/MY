      // ===== AUTHENTICATION FUNCTIONS =====
function showAuthModal() {
    document.getElementById('authModal').classList.add('active');
}

function closeAuthModal() {
    document.getElementById('authModal').classList.remove('active');
    document.getElementById('signin-error').style.display = 'none';
    
    // Hide all signup forms and show selection
    document.getElementById('signup-selection').style.display = 'none';
    document.getElementById('signup-student-form').style.display = 'none';
    document.getElementById('signup-coach-form').style.display = 'none';
    document.getElementById('signup-organization-form').style.display = 'none';
    
    // Clear all error messages
    document.querySelectorAll('.feedback.error').forEach(el => el.style.display = 'none');
}

function switchAuthTab(tab) {
    document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.auth-form').forEach(f => {
        f.classList.remove('active');
        f.style.display = 'none'; // Force hide all forms
    });
    
    if (tab === 'signin') {
        document.querySelector('.auth-tab:first-child').classList.add('active');
        document.getElementById('signin-form').classList.add('active');
        document.getElementById('signin-form').style.display = 'block';
        
        // Hide all signup forms
        document.getElementById('signup-selection').style.display = 'none';
        document.getElementById('signup-student-form').style.display = 'none';
        document.getElementById('signup-coach-form').style.display = 'none';
        document.getElementById('signup-organization-form').style.display = 'none';
    } else {
        document.querySelector('.auth-tab:last-child').classList.add('active');
        document.getElementById('signup-selection').classList.add('active');
        document.getElementById('signup-selection').style.display = 'block';
        
        // Hide signin form
        document.getElementById('signin-form').style.display = 'none';
    }
}

function showSignUpForm(userType) {
    // Hide selection screen
    document.getElementById('signup-selection').style.display = 'none';
    
    // Show appropriate form
    if (userType === 'student') {
        document.getElementById('signup-student-form').style.display = 'block';
    } else if (userType === 'parent') {
        document.getElementById('signup-parent-form').style.display = 'block';
    } else if (userType === 'coach') {
        document.getElementById('signup-coach-form').style.display = 'block';
    } else if (userType === 'organization') {
        document.getElementById('signup-organization-form').style.display = 'block';
    }
}

function backToUserTypeSelection() {
    // Hide all forms
    document.getElementById('signup-student-form').style.display = 'none';
    document.getElementById('signup-parent-form').style.display = 'none';
    document.getElementById('signup-coach-form').style.display = 'none';
    document.getElementById('signup-organization-form').style.display = 'none';
    
    // Show selection
    document.getElementById('signup-selection').style.display = 'block';
}
        
async function handleSignIn(event) {
    event.preventDefault();
    const email = document.getElementById('signin-email').value;
    const password = document.getElementById('signin-password').value;
    const errorDiv = document.getElementById('signin-error');

    try {
        const userCredential = await auth.signInWithEmailAndPassword(email, password);
        const user = userCredential.user;
        
        // Check if user document exists in Firestore
        const userDoc = await db.collection('users').doc(user.uid).get();
        
        if (!userDoc.exists) {
            // User signed in but no profile exists - sign them out
            await auth.signOut();
            errorDiv.textContent = 'No account found with this email. Please sign up first.';
            errorDiv.style.display = 'block';
            return;
        }
        
        // Check if profile is complete
        const userData = userDoc.data();
        if (!userData.profileComplete) {
            // Show verification modal
            closeAuthModal();
            showVerificationModal(userData);
            return;
        }
        
        closeAuthModal();
        errorDiv.style.display = 'none';
    } catch (error) {
        if (error.code === 'auth/user-not-found') {
            errorDiv.textContent = 'No account found with this email. Please sign up first.';
        } else if (error.code === 'auth/wrong-password') {
            errorDiv.textContent = 'Incorrect password. Please try again.';
        } else if (error.code === 'auth/invalid-email') {
            errorDiv.textContent = 'Invalid email address.';
        } else {
            errorDiv.textContent = error.message;
        }
        errorDiv.style.display = 'block';
    }
}

async function handleSignUp(event, userType) {
    event.preventDefault();
    
    let name, email, password, errorDiv;
    let additionalData = { 
        userType: userType,
        profileComplete: false // Mark as incomplete
    };
    
    if (userType === 'student') {
        name = document.getElementById('signup-student-name').value;
        email = document.getElementById('signup-student-email').value;
        password = document.getElementById('signup-student-password').value;
        errorDiv = document.getElementById('signup-student-error');
        additionalData.age = document.getElementById('signup-student-age').value;
        additionalData.country = document.getElementById('signup-student-country').value;
        
        // For students, if they provided age and country, mark complete
        if (additionalData.age && additionalData.country) {
            additionalData.profileComplete = true;
        }
    } else if (userType === 'coach') {
        name = document.getElementById('signup-coach-name').value;
        email = document.getElementById('signup-coach-email').value;
        password = document.getElementById('signup-coach-password').value;
        errorDiv = document.getElementById('signup-coach-error');
        additionalData.organization = document.getElementById('signup-coach-organization').value;
        additionalData.profileComplete = true; // Coaches don't need extra verification
    } else if (userType === 'organization') {
        name = document.getElementById('signup-org-name').value;
        email = document.getElementById('signup-org-email').value;
        password = document.getElementById('signup-org-password').value;
        errorDiv = document.getElementById('signup-org-error');
        additionalData.phone = document.getElementById('signup-org-phone').value;
        additionalData.address = document.getElementById('signup-org-address').value;
        additionalData.profileComplete = true; // Organizations don't need extra verification
    }

    try {
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        await userCredential.user.updateProfile({ displayName: name });
        
        // ‚úÖ GENERATE STUDENT ID FOR STUDENTS
        if (userType === 'student') {
            additionalData.studentId = generateStudentId(userCredential.user.uid);
            console.log('‚úÖ Generated Student ID:', additionalData.studentId);
        }
        
        await db.collection('users').doc(userCredential.user.uid).set({
            name: name,
            email: email,
            ...additionalData,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        closeAuthModal();
        errorDiv.style.display = 'none';
        
        // If profile not complete, show verification modal
        if (!additionalData.profileComplete) {
            showVerificationModal({ name, email, userType });
        } else {
            if (userType === 'student') {
                alert(`Welcome, ${name}! Your student account has been created successfully.\n\nYour Student ID: ${additionalData.studentId}\n\nPlease save this ID - your parent will need it to link their account.`);
            } else {
                alert(`Welcome, ${name}! Your ${userType} account has been created successfully.`);
            }
        }
    } catch (error) {
        errorDiv.textContent = error.message;
        errorDiv.style.display = 'block';
    }
}
        
function signOut() {
    // Remove online presence before signing out
    removeOnlinePresence();
    
    // ‚úÖ CLEAR DECLINED CHALLENGES
    declinedChallengeIds.clear();
    shownPopupIds.clear();
    shownQuizPopupIds.clear();
    
    // Sign out from Firebase
    auth.signOut();
    
    // Navigate to home
    navigateTo('home');
}

async function signInWithGoogle() {
    const provider = new firebase.auth.GoogleAuthProvider();
    try {
        const result = await auth.signInWithPopup(provider);
        const user = result.user;
        
        // Check if user document exists
        const userRef = db.collection('users').doc(user.uid);
        const userDoc = await userRef.get();
        
        if (!userDoc.exists) {
            // ‚úÖ NOW SAVING photoURL
            await userRef.set({
                name: user.displayName,
                email: user.email,
                photoURL: user.photoURL || null, // ‚úÖ ADD THIS
                userType: 'student',
                profileComplete: false,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            closeAuthModal();
            showVerificationModal({
                name: user.displayName,
                email: user.email,
                userType: 'student'
            });
        } else {
            // Existing user - check if profile is complete
            const userData = userDoc.data();
            if (!userData.profileComplete) {
                closeAuthModal();
                showVerificationModal(userData);
            } else {
                closeAuthModal();
            }
        }
    } catch (error) {
        console.error('Google sign-in error:', error);
        document.getElementById('signin-error').textContent = error.message;
        document.getElementById('signin-error').style.display = 'block';
    }
}
        
async function signUpWithGoogle(userType) {
    const provider = new firebase.auth.GoogleAuthProvider();
    try {
        const result = await auth.signInWithPopup(provider);
        const user = result.user;
        
        const userRef = db.collection('users').doc(user.uid);
        
        // ‚úÖ Generate student ID if signing up as student
        const userData = {
            name: user.displayName,
            email: user.email,
            photoURL: user.photoURL || null,
            userType: userType,
            profileComplete: false,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        if (userType === 'student') {
            userData.studentId = generateStudentId(user.uid);
        }
        
        await userRef.set(userData);
        
        closeAuthModal();
        showVerificationModal({
            name: user.displayName,
            email: user.email,
            userType: userType
        });
    } catch (error) {
        console.error('Google sign-up error:', error);
        const errorDiv = document.getElementById(`signup-${userType}-error`);
        errorDiv.textContent = error.message;
        errorDiv.style.display = 'block';
    }
}
        
        // ===== VERIFICATION MODAL FUNCTIONS =====
function showVerificationModal(userData) {
    const modal = document.getElementById('verificationModal');
    
    // Pre-fill any existing data
    if (userData.name) {
        document.getElementById('verify-name').value = userData.name;
    }
    if (userData.age) {
        document.getElementById('verify-age').value = userData.age;
    }
    if (userData.country) {
        document.getElementById('verify-country').value = userData.country;
    }
    
    modal.classList.add('active');
}

function closeVerificationModal() {
    document.getElementById('verificationModal').classList.remove('active');
}

async function handleVerification(event) {
    event.preventDefault();
    
    if (!currentUser) {
        alert('Session expired. Please sign in again.');
        return;
    }
    
    const name = document.getElementById('verify-name').value.trim();
    const age = document.getElementById('verify-age').value;
    const country = document.getElementById('verify-country').value;
    const errorDiv = document.getElementById('verify-error');
    
    if (!name || !age || !country) {
        errorDiv.textContent = 'All fields are required.';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (age < 5 || age > 100) {
        errorDiv.textContent = 'Please enter a valid age between 5 and 100.';
        errorDiv.style.display = 'block';
        return;
    }
    
    try {
        // Update Firestore
        await db.collection('users').doc(currentUser.uid).update({
            name: name,
            age: parseInt(age),
            country: country,
            profileComplete: true
        });
        
        // Update Firebase Auth profile
        await currentUser.updateProfile({ displayName: name });
        
        errorDiv.style.display = 'none';
        closeVerificationModal();
        
        alert('‚úÖ Profile completed successfully! Welcome to WordBiz Coaching Academy!');
        
        // Refresh UI
        updateUIForAuthenticatedUser(currentUser);
    } catch (error) {
        console.error('Error completing profile:', error);
        errorDiv.textContent = 'Failed to complete profile: ' + error.message;
        errorDiv.style.display = 'block';
    }
}

        async function signOutAndSwitchAccount() {
    if (confirm('‚ö†Ô∏è Are you sure you want to sign out? You will need to sign in with a different account.')) {
        try {
            // Close verification modal
            closeVerificationModal();
            
            // Sign out the user
            await auth.signOut();
            
            // Reset UI to guest state
            currentUser = null;
            updateUIForGuestUser();
            
            // Navigate to home
            navigateTo('home');
            
            // Show auth modal for them to sign in/up with different account
            setTimeout(() => {
                showAuthModal();
            }, 500);
            
        } catch (error) {
            console.error('Error signing out:', error);
            alert('Failed to sign out: ' + error.message);
        }
    }
}

        // ===== ID VERIFICATION FUNCTIONS =====

function showVerificationModal(userData) {
    const modal = document.getElementById('verificationModal');
    const idSection = document.getElementById('coachIdVerification');
    const completeBtn = document.getElementById('completeProfileBtn');
    
    // Pre-fill any existing data
    if (userData.name) {
        document.getElementById('verify-name').value = userData.name;
    }
    if (userData.age) {
        document.getElementById('verify-age').value = userData.age;
    }
    if (userData.country) {
        document.getElementById('verify-country').value = userData.country;
    }
    
    // Check if this is a coach
    isCoachVerification = (userData.userType === 'coach');
    
    if (isCoachVerification) {
        idSection.classList.add('show');
        completeBtn.textContent = '‚è≥ Upload ID to Continue';
        completeBtn.disabled = true;
    } else {
        idSection.classList.remove('show');
        completeBtn.textContent = '‚úÖ Complete Profile';
        completeBtn.disabled = false;
    }
    
    // Reset ID verification state
    uploadedIDFile = null;
    uploadedIDBase64 = null;
    idVerificationPassed = false;
    document.getElementById('idPreviewContainer').classList.remove('show');
    document.getElementById('idVerificationStatus').classList.remove('show');
    
    modal.classList.add('active');
}

// Handle ID file upload
function handleIDUpload(event) {
    const file = event.target.files[0];
    
    if (!file) return;
    
    // Validate file size (10MB max)
    if (file.size > 10 * 1024 * 1024) {
        alert('File is too large. Maximum size is 10MB.');
        return;
    }
    
    // Validate file type
    const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'application/pdf'];
    if (!validTypes.includes(file.type)) {
        alert('Invalid file type. Please upload JPG, PNG, or PDF.');
        return;
    }
    
    uploadedIDFile = file;
    
    // Convert to base64 for preview and API
    const reader = new FileReader();
    reader.onload = function(e) {
        uploadedIDBase64 = e.target.result.split(',')[1]; // Remove data:image/jpeg;base64, prefix
        
        // Show preview for images only
        if (file.type.startsWith('image/')) {
            document.getElementById('idPreviewImage').src = e.target.result;
            document.getElementById('idPreviewContainer').classList.add('show');
        } else {
            document.getElementById('idPreviewContainer').classList.remove('show');
        }
        
        // Automatically start verification
        verifyIDWithAI();
    };
    reader.readAsDataURL(file);
}

// Drag and drop support
document.addEventListener('DOMContentLoaded', function() {
    const uploadArea = document.getElementById('idUploadArea');
    
    if (uploadArea) {
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.add('drag-over');
            }, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.remove('drag-over');
            }, false);
        });
        
        uploadArea.addEventListener('drop', function(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                document.getElementById('verify-id-file').files = files;
                handleIDUpload({ target: { files: files } });
            }
        }, false);
    }
});

function changeIDPhoto() {
    document.getElementById('verify-id-file').value = '';
    document.getElementById('idPreviewContainer').classList.remove('show');
    document.getElementById('idVerificationStatus').classList.remove('show');
    uploadedIDFile = null;
    uploadedIDBase64 = null;
    idVerificationPassed = false;
    document.getElementById('completeProfileBtn').disabled = true;
    document.getElementById('completeProfileBtn').textContent = '‚è≥ Upload ID to Continue';
}

// Verify ID using AI
async function verifyIDWithAI() {
    if (!uploadedIDBase64) {
        alert('Please upload an ID first');
        return;
    }
    
    const statusDiv = document.getElementById('idVerificationStatus');
    const completeBtn = document.getElementById('completeProfileBtn');
    const coachName = document.getElementById('verify-name').value.trim();
    const coachAge = document.getElementById('verify-age').value.trim(); // ‚úÖ GET AGE
    
    if (!coachName) {
        alert('Please enter your full name first');
        return;
    }
    
    if (!coachAge) {
        alert('Please enter your age first');
        return;
    }
    
    // Show verifying status
    statusDiv.className = 'id-verification-status verifying show';
    statusDiv.innerHTML = `
        <div class="verification-spinner"></div>
        <strong>Verifying your ID...</strong>
        <p style="margin-top: 8px;">This may take 10-20 seconds. Please wait...</p>
    `;
    
    completeBtn.disabled = true;
    completeBtn.textContent = '‚è≥ Verifying ID...';
    
    try {
        const response = await fetch(CLOUD_FUNCTION_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                data: {
                    action: 'verifyCoachID',
                    imageBase64: uploadedIDBase64,
                    coachName: coachName,
                    userAge: coachAge, // ‚úÖ SEND AGE
                    userId: currentUser.uid
                }
            })
        });
        
        if (!response.ok) {
            throw new Error(`Verification failed: ${response.status}`);
        }
        
        const data = await response.json();
        const result = data.result;
        
        console.log('Verification result:', result);
        
        // ‚úÖ SIMPLIFIED: Check if verification passed
        if (result.verificationPassed) {
            // ‚úÖ SUCCESS - CLEAN MESSAGE
            idVerificationPassed = true;
            statusDiv.className = 'id-verification-status success show';
            statusDiv.innerHTML = `
                <strong>‚úÖ ID Verified Successfully!</strong>
                <p style="margin-top: 8px;">
                    <strong>Status:</strong> Text is clear and consistent with a standard passport layout.
                </p>
                <p style="margin-top: 10px; font-size: 0.9rem; font-style: italic;">
                    üîí Your ID photo has not been stored. Only verification status is saved.
                </p>
            `;
            
            completeBtn.disabled = false;
            completeBtn.textContent = '‚úÖ COMPLETE PROFILE';
            
            // Store verification result in Firestore
            await db.collection('users').doc(currentUser.uid).update({
                idVerified: true,
                idVerificationDate: firebase.firestore.FieldValue.serverTimestamp(),
                idDocumentType: result.documentType,
                idVerificationConfidence: result.confidence,
                verifiedAge: result.age
            });
            
        } else {
            // ‚úÖ FAILURE - CLEAN MESSAGE
            idVerificationPassed = false;
            statusDiv.className = 'id-verification-status error show';
            
            statusDiv.innerHTML = `
                <strong>Verification Failed</strong>
                <p style="margin-top: 8px;">${result.reason || 'Unable to verify your ID.'}</p>
                <p style="margin-top: 10px; font-size: 0.9rem;">
                    <strong>Tips for better verification:</strong><br>
                    ‚Ä¢ Ensure good lighting<br>
                    ‚Ä¢ Avoid glare or shadows<br>
                    ‚Ä¢ Make sure all text is readable<br>
                    ‚Ä¢ Use the original, unedited document<br>
                    ‚Ä¢ Ensure the name you typed matches the ID exactly
                </p>
            `;
            
            completeBtn.disabled = true;
            completeBtn.textContent = '‚ùå Upload Valid ID';
        }
        
    } catch (error) {
        console.error('ID Verification Error:', error);
        idVerificationPassed = false;
        statusDiv.className = 'id-verification-status error show';
        statusDiv.innerHTML = `
            <strong>‚ùå Verification Error</strong>
            <p style="margin-top: 8px;">
                Unable to verify your ID. This could be due to:<br>
                ‚Ä¢ Poor image quality<br>
                ‚Ä¢ Network connection issues<br>
                ‚Ä¢ Unsupported document format
            </p>
            <p style="margin-top: 10px;">
                Error details: ${error.message}
            </p>
            <p style="margin-top: 10px; font-weight: bold;">
                Please try uploading a clearer photo of your ID.
            </p>
        `;
        
        completeBtn.disabled = true;
        completeBtn.textContent = '‚ùå Upload Valid ID';
    }
}
        
// Update handleVerification function to include ID check
async function handleVerification(event) {
    event.preventDefault();
    
    if (!currentUser) {
        alert('Session expired. Please sign in again.');
        return;
    }
    
    const name = document.getElementById('verify-name').value.trim();
    const age = document.getElementById('verify-age').value;
    const country = document.getElementById('verify-country').value;
    const errorDiv = document.getElementById('verify-error');
    
    if (!name || !age || !country) {
        errorDiv.textContent = 'All fields are required.';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (age < 5 || age > 100) {
        errorDiv.textContent = 'Please enter a valid age between 5 and 100.';
        errorDiv.style.display = 'block';
        return;
    }
    
    // Check if coach needs ID verification
    if (isCoachVerification && !idVerificationPassed) {
        errorDiv.textContent = 'Please upload and verify your government-issued ID to continue.';
        errorDiv.style.display = 'block';
        return;
    }
    
    try {
        // ‚úÖ Update Firestore - PRESERVE photoURL
        const updateData = {
            name: name,
            age: parseInt(age),
            country: country,
            profileComplete: true
        };
        
        // Only add photoURL if it exists (don't overwrite with null)
        if (currentUser.photoURL) {
            updateData.photoURL = currentUser.photoURL;
        }
        
        await db.collection('users').doc(currentUser.uid).update(updateData);
        
        // Update Firebase Auth profile
        await currentUser.updateProfile({ displayName: name });
        
        errorDiv.style.display = 'none';
        closeVerificationModal();
        
        if (isCoachVerification) {
            alert('‚úÖ Profile and ID verification completed successfully! Welcome to WordBiz Coaching Academy!');
        } else {
            alert('‚úÖ Profile completed successfully! Welcome to WordBiz Coaching Academy!');
        }
        
        // Refresh UI
        updateUIForAuthenticatedUser(currentUser);
    } catch (error) {
        console.error('Error completing profile:', error);
        errorDiv.textContent = 'Failed to complete profile: ' + error.message;
        errorDiv.style.display = 'block';
    }
}
        


// ===== PARENT ID UPLOAD FUNCTIONS =====
function handleParentIDUpload(event) {
    const file = event.target.files[0];
    
    if (!file) return;
    
    if (file.size > 10 * 1024 * 1024) {
        alert('File is too large. Maximum size is 10MB.');
        return;
    }
    
    const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'application/pdf'];
    if (!validTypes.includes(file.type)) {
        alert('Invalid file type. Please upload JPG, PNG, or PDF.');
        return;
    }
    
    parentIDFile = file;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        parentIDBase64 = e.target.result.split(',')[1];
        
        if (file.type.startsWith('image/')) {
            document.getElementById('parent-id-preview-image').src = e.target.result;
            document.getElementById('parent-id-preview').style.display = 'block';
        }
        
        verifyParentID();
    };
    reader.readAsDataURL(file);
}

function changeParentID() {
    document.getElementById('parent-id-file').value = '';
    document.getElementById('parent-id-preview').style.display = 'none';
    document.getElementById('parent-id-status').style.display = 'none';
    parentIDFile = null;
    parentIDBase64 = null;
    parentIDVerified = false;
}

async function verifyParentID() {
    if (!parentIDBase64) {
        alert('Please upload parent ID first');
        return;
    }
    
    const statusDiv = document.getElementById('parent-id-status');
    const parentName = document.getElementById('signup-parent-name').value.trim();
    
    if (!parentName) {
        alert('Please enter parent name first');
        return;
    }
    
    statusDiv.className = 'id-verification-status verifying show';
    statusDiv.style.display = 'block';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.borderLeft = '4px solid #ffc107';
    statusDiv.style.padding = '15px';
    statusDiv.style.borderRadius = '8px';
    statusDiv.style.color = '#856404';
    statusDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
            <div class="verification-spinner"></div>
            <strong>Verifying parent ID...</strong>
        </div>
        <p style="margin-top: 8px;">This may take 10-20 seconds. Please wait...</p>
    `;
    
    try {
        const response = await fetch(CLOUD_FUNCTION_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                data: {
                    action: 'verifyCoachID',
                    imageBase64: parentIDBase64,
                    coachName: parentName,
                    userId: 'temp-parent-' + Date.now()
                }
            })
        });
        
        if (!response.ok) {
            throw new Error(`Verification failed: ${response.status}`);
        }
        
        const data = await response.json();
        const result = data.result;
        
        if (result.isValid && result.isOver16 && !result.documentAppearsTampered) {
            parentIDVerified = true;
            statusDiv.style.background = '#d4edda';
            statusDiv.style.borderLeft = '4px solid #28a745';
            statusDiv.style.color = '#155724';
            statusDiv.innerHTML = `
                <strong>‚úÖ Parent ID Verified Successfully!</strong>
                <p style="margin-top: 8px;">
                    <strong>Document:</strong> ${result.documentType}<br>
                    <strong>Name:</strong> ${result.fullName}<br>
                    <strong>Age:</strong> ${result.age} years old
                </p>
            `;
        } else {
            parentIDVerified = false;
            statusDiv.style.background = '#f8d7da';
            statusDiv.style.borderLeft = '4px solid #dc3545';
            statusDiv.style.color = '#721c24';
            
            let errorMessage = result.reason || 'Verification failed';
            
            if (!result.isValid) {
                errorMessage = '‚ùå Invalid or unrecognized document. Please upload a clear photo of your Driver\'s License, Passport, or National ID.';
            } else if (!result.isOver16) {
                errorMessage = '‚ùå Parent must be at least 16 years old.';
            } else if (result.documentAppearsTampered) {
                errorMessage = '‚ùå Document appears to be altered. Please upload an original, unedited ID.';
            }
            
            statusDiv.innerHTML = `
                <strong>Verification Failed</strong>
                <p style="margin-top: 8px;">${errorMessage}</p>
            `;
        }
    } catch (error) {
        console.error('Parent ID Verification Error:', error);
        parentIDVerified = false;
        statusDiv.style.background = '#f8d7da';
        statusDiv.style.borderLeft = '4px solid #dc3545';
        statusDiv.style.color = '#721c24';
        statusDiv.innerHTML = `
            <strong>‚ùå Verification Error</strong>
            <p style="margin-top: 8px;">
                Unable to verify ID. Please ensure:<br>
                ‚Ä¢ Good lighting<br>
                ‚Ä¢ All text is readable<br>
                ‚Ä¢ No glare or shadows
            </p>
        `;
    }
}

// ===== CHILD ID UPLOAD FUNCTIONS =====
function handleChildIDUpload(event) {
    const file = event.target.files[0];
    
    if (!file) return;
    
    if (file.size > 10 * 1024 * 1024) {
        alert('File is too large. Maximum size is 10MB.');
        return;
    }
    
    const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'application/pdf'];
    if (!validTypes.includes(file.type)) {
        alert('Invalid file type. Please upload JPG, PNG, or PDF.');
        return;
    }
    
    childIDFile = file;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        childIDBase64 = e.target.result.split(',')[1];
        
        if (file.type.startsWith('image/')) {
            document.getElementById('child-id-preview-image').src = e.target.result;
            document.getElementById('child-id-preview').style.display = 'block';
        }
        
        verifyChildID();
    };
    reader.readAsDataURL(file);
}

function changeChildID() {
    document.getElementById('child-id-file').value = '';
    document.getElementById('child-id-preview').style.display = 'none';
    document.getElementById('child-id-status').style.display = 'none';
    childIDFile = null;
    childIDBase64 = null;
    childIDVerified = false;
}

async function verifyChildID() {
    if (!childIDBase64) {
        alert('Please upload child ID first');
        return;
    }
    
    const statusDiv = document.getElementById('child-id-status');
    const childName = document.getElementById('signup-child-name').value.trim();
    
    if (!childName) {
        alert('Please enter child name first');
        return;
    }
    
    statusDiv.className = 'id-verification-status verifying show';
    statusDiv.style.display = 'block';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.borderLeft = '4px solid #ffc107';
    statusDiv.style.padding = '15px';
    statusDiv.style.borderRadius = '8px';
    statusDiv.style.color = '#856404';
    statusDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
            <div class="verification-spinner"></div>
            <strong>Verifying child ID...</strong>
        </div>
        <p style="margin-top: 8px;">This may take 10-20 seconds. Please wait...</p>
    `;
    
    try {
        const response = await fetch(CLOUD_FUNCTION_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                data: {
                    action: 'verifyCoachID',
                    imageBase64: childIDBase64,
                    coachName: childName,
                    userId: 'temp-child-' + Date.now()
                }
            })
        });
        
        if (!response.ok) {
            throw new Error(`Verification failed: ${response.status}`);
        }
        
        const data = await response.json();
        const result = data.result;
        
        // ‚úÖ ADD: Check if name matches
        const nameMatches = result.fullName && 
            (result.fullName.toLowerCase().includes(childName.toLowerCase().split(' ')[0]) ||
            childName.toLowerCase().includes(result.fullName.toLowerCase().split(' ')[0]));
        
        // For children, we accept any valid document with matching name
        if (result.isValid && !result.documentAppearsTampered && nameMatches) {
            childIDVerified = true;
            statusDiv.style.background = '#d4edda';
            statusDiv.style.borderLeft = '4px solid #28a745';
            statusDiv.style.color = '#155724';
            statusDiv.innerHTML = `
                <strong>‚úÖ Child ID Verified Successfully!</strong>
                <p style="margin-top: 8px;">
                    <strong>Document:</strong> ${result.documentType}<br>
                    <strong>Name on ID:</strong> ${result.fullName}<br>
                    <strong>Your Child's Name:</strong> ${childName}
                    ${result.age ? `<br><strong>Age:</strong> ${result.age} years old` : ''}
                </p>
            `;
        } else {
            childIDVerified = false;
            statusDiv.style.background = '#f8d7da';
            statusDiv.style.borderLeft = '4px solid #dc3545';
            statusDiv.style.color = '#721c24';
            
            let errorMessage = result.reason || 'Verification failed';
            
            if (!result.isValid) {
                errorMessage = '‚ùå Invalid or unrecognized document. Please upload a clear photo of the child\'s Birth Certificate, Student ID, or Government ID.';
            } else if (result.documentAppearsTampered) {
                errorMessage = '‚ùå Document appears to be altered. Please upload an original, unedited ID.';
            } else if (!nameMatches) {
                errorMessage = `‚ùå Name mismatch! The name on the ID (${result.fullName}) does not match the child's name you entered (${childName}).`;
            }
            
            statusDiv.innerHTML = `
                <strong>Verification Failed</strong>
                <p style="margin-top: 8px;">${errorMessage}</p>
                ${result.fullName ? `<p style="margin-top: 5px;"><strong>Detected Name:</strong> ${result.fullName}</p>` : ''}
            `;
        }
    } catch (error) {
        console.error('Child ID Verification Error:', error);
        childIDVerified = false;
        statusDiv.style.background = '#f8d7da';
        statusDiv.style.borderLeft = '4px solid #dc3545';
        statusDiv.style.color = '#721c24';
        statusDiv.innerHTML = `
            <strong>‚ùå Verification Error</strong>
            <p style="margin-top: 8px;">
                Unable to verify ID. Please ensure:<br>
                ‚Ä¢ Good lighting<br>
                ‚Ä¢ All text is readable<br>
                ‚Ä¢ No glare or shadows<br>
                ‚Ä¢ Name matches exactly
            </p>
        `;
    }
}

// ===== PARENT SIGN UP HANDLER =====
async function handleParentSignUp(event) {
    event.preventDefault();
    
    const errorDiv = document.getElementById('signup-parent-error');
    
    // Check ID verifications
    if (!parentIDVerified) {
        errorDiv.textContent = '‚ùå Please upload and verify parent ID first';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (!childIDVerified) {
        errorDiv.textContent = '‚ùå Please upload and verify child ID first';
        errorDiv.style.display = 'block';
        return;
    }
    
    const parentName = document.getElementById('signup-parent-name').value.trim();
    const email = document.getElementById('signup-parent-email').value.trim();
    const password = document.getElementById('signup-parent-password').value;
    const phone = document.getElementById('signup-parent-phone').value.trim();
    const country = document.getElementById('signup-parent-country').value;
    
    const childName = document.getElementById('signup-child-name').value.trim();
    const childAge = document.getElementById('signup-child-age').value;
    const childStudentId = document.getElementById('signup-child-student-id').value.trim();
    
    // Validate student ID format
    const studentIdPattern = /^WB-2025-[A-Z0-9]{4}$/;
    if (!studentIdPattern.test(childStudentId)) {
        errorDiv.textContent = '‚ùå Invalid student ID format. Must be WB-2025-XXXX';
        errorDiv.style.display = 'block';
        return;
    }
    
    // Verify student ID exists in database
    try {
        const studentQuery = await db.collection('users')
            .where('studentId', '==', childStudentId)
            .where('userType', '==', 'student')
            .get();
        
        if (studentQuery.empty) {
            errorDiv.textContent = '‚ùå Student ID not found. Please verify the ID is correct.';
            errorDiv.style.display = 'block';
            return;
        }
        
        const studentDoc = studentQuery.docs[0];
        const studentData = studentDoc.data();
        
        // Check if student name matches
        if (studentData.name.toLowerCase() !== childName.toLowerCase()) {
            errorDiv.textContent = `‚ùå Student name does not match. Registered name: ${studentData.name}`;
            errorDiv.style.display = 'block';
            return;
        }
        
        // Check if student already has a parent
        if (studentData.parentId) {
            errorDiv.textContent = '‚ùå This student already has a parent account linked.';
            errorDiv.style.display = 'block';
            return;
        }
        
        // Disable submit button
        const submitBtn = document.getElementById('parent-signup-btn');
        submitBtn.disabled = true;
        submitBtn.textContent = '‚è≥ Creating account...';
        
        // Create parent account
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        await userCredential.user.updateProfile({ displayName: parentName });
        
        // Save parent data to Firestore
        await db.collection('users').doc(userCredential.user.uid).set({
            name: parentName,
            email: email,
            phone: phone,
            country: country,
            userType: 'parent',
            parentIDVerified: true,
            childIDVerified: true,
            childStudentId: childStudentId,
            childName: childName,
            childAge: parseInt(childAge),
            linkedStudentId: studentDoc.id,
            profileComplete: true,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        // Link parent to student
        await db.collection('users').doc(studentDoc.id).update({
            parentId: userCredential.user.uid,
            parentName: parentName,
            parentEmail: email,
            parentLinkedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        closeAuthModal();
        errorDiv.style.display = 'none';
        
        alert(`‚úÖ Parent account created successfully!\n\nYou are now linked to student: ${childName}\nStudent ID: ${childStudentId}`);
        
        // Reset form
        document.getElementById('signup-parent-form').reset();
        parentIDFile = null;
        parentIDBase64 = null;
        childIDFile = null;
        childIDBase64 = null;
        parentIDVerified = false;
        childIDVerified = false;
        
    } catch (error) {
        console.error('Error creating parent account:', error);
        errorDiv.textContent = 'Failed to create account: ' + error.message;
        errorDiv.style.display = 'block';
        
        const submitBtn = document.getElementById('parent-signup-btn');
        submitBtn.disabled = false;
        submitBtn.textContent = '‚úÖ Create Parent Account';
    }
}        
     async function updateUIForAuthenticatedUser(user) {
    const displayName = user.displayName || user.email.split('@')[0];
    const photoURL = user.photoURL;
    
    // Update sidebar
    document.getElementById('sidebarUserName').textContent = displayName;
    const sidebarAvatar = document.getElementById('sidebarUserAvatar');
    
    if (photoURL) {
        sidebarAvatar.style.backgroundImage = `url(${photoURL})`;
        sidebarAvatar.textContent = '';
    } else {
        sidebarAvatar.style.backgroundImage = 'none';
        sidebarAvatar.textContent = displayName.charAt(0).toUpperCase();
    }
    
    // ‚úÖ SHOW MY PROFILE BUTTON BASED ON USER TYPE
    const myProfileBtn = document.getElementById('myProfileBtn');
    
    try {
        const userDoc = await db.collection('users').doc(user.uid).get();
        const userData = userDoc.data();
        
        if (userData && userData.userType === 'parent') {
            myProfileBtn.innerHTML = 'üë®‚Äçüë©‚Äçüëß PARENT DASHBOARD';
            myProfileBtn.onclick = () => goToParentDashboard();
        } else if (userData && userData.userType === 'coach') {
            myProfileBtn.innerHTML = 'üë®‚Äçüè´ MY PROFILE';
            myProfileBtn.onclick = () => goToUserDashboard();
        } else {
            myProfileBtn.innerHTML = 'üë§ MY PROFILE';
            myProfileBtn.onclick = () => goToUserDashboard();
        }
        
        myProfileBtn.style.display = 'block';
    } catch (error) {
        console.error('Error loading user type:', error);
        myProfileBtn.innerHTML = 'üë§ MY PROFILE';
        myProfileBtn.onclick = () => goToUserDashboard();
        myProfileBtn.style.display = 'block';
    }
    
    document.getElementById('sidebar-signin').style.display = 'none';
    document.getElementById('sidebar-signout').style.display = 'block';
}

        
      function updateUIForGuestUser() {
    document.getElementById('sidebarUserName').textContent = 'Guest';
    const sidebarAvatar = document.getElementById('sidebarUserAvatar');
    sidebarAvatar.style.backgroundImage = 'none';
    sidebarAvatar.textContent = '?';
    
    // Hide My Profile button
    document.getElementById('myProfileBtn').style.display = 'none';
    
    document.getElementById('sidebar-signin').style.display = 'block';
    document.getElementById('sidebar-signout').style.display = 'none';
    userFavorites = [];
    userIncorrect = [];
    userSpellingFavorites = [];
    userSpellingIncorrect = [];
    
    // ‚úÖ HIDE COINS
    userCoins = 0;
    hideCoinDisplay();
    
    document.getElementById('favorites-container').innerHTML = '<div class="loading">Please sign in to save favorites</div>';
    document.getElementById('incorrect-container').innerHTML = '<div class="loading">Please sign in to track incorrect answers</div>';
    document.getElementById('spelling-favorites-container').innerHTML = '<div class="loading">Please sign in to save spelling favorites</div>';
    document.getElementById('spelling-incorrect-container').innerHTML = '<div class="loading">Please sign in to track spelling mistakes</div>';
}



// ===== COACHES DISPLAY FUNCTIONS =====
async function loadAndDisplayCoaches() {
    const container = document.getElementById('coaches-container');
    
    try {
        container.innerHTML = '<div class="loading">üìö Loading coaches...</div>';
        
        console.log('üîç Fetching coaches from Firestore...');
        
        // Fetch all coaches from Firestore
        const coachesSnapshot = await db.collection('users')
            .where('userType', '==', 'coach')
            .get();
        
        console.log('üìä Found coaches:', coachesSnapshot.size);
        
        if (coachesSnapshot.empty) {
            container.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #666;">
                    <div style="font-size: 3rem; margin-bottom: 20px;">üë®‚Äçüè´</div>
                    <h3>No coaches registered yet</h3>
                    <p>Be the first to join as a coach!</p>
                </div>
            `;
            return;
        }
        
        const coaches = [];
        coachesSnapshot.forEach(doc => {
            const data = doc.data();
            console.log('üë§ Coach:', doc.id, data.name, data.photoURL);
            coaches.push({ id: doc.id, ...data });
        });
        
        // Sort coaches (newest first)
        coaches.sort((a, b) => {
            if (!a.createdAt) return 1;
            if (!b.createdAt) return -1;
            return b.createdAt.toDate() - a.createdAt.toDate();
        });
        
        // Calculate stats
        const totalCoaches = coaches.length;
        const verifiedCoaches = coaches.filter(c => c.idVerified).length;
        const pendingCoaches = totalCoaches - verifiedCoaches;
        
        // Display stats and table
        container.innerHTML = `
            <!-- Stats Cards -->
            <div class="coach-stats">
                <div class="coach-stat-card">
                    <div class="stat-number">${totalCoaches}</div>
                    <div class="stat-label">Total Coaches</div>
                </div>
                <div class="coach-stat-card">
                    <div class="stat-number">${verifiedCoaches}</div>
                    <div class="stat-label">Verified</div>
                </div>
                <div class="coach-stat-card">
                    <div class="stat-number">${pendingCoaches}</div>
                    <div class="stat-label">‚è≥ Pending</div>
                </div>
            </div>
            
            <!-- Coaches Table -->
            <div class="coaches-table">
                <table>
                    <thead>
                        <tr>
                            <th>üë®‚Äçüè´ Coach</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${coaches.map(coach => {
                            // Determine avatar display
                            let avatarStyle = '';
                            let avatarText = '';
                            
                            if (coach.photoURL) {
                                avatarStyle = `style="background-image: url('${coach.photoURL}'); background-size: cover; background-position: center;"`;
                                avatarText = '';
                            } else {
                                const initial = (coach.name || 'C').charAt(0).toUpperCase();
                                avatarStyle = '';
                                avatarText = initial;
                            }
                            
                            return `
                                <tr onclick="showCoachDetailById('${coach.id}')" style="cursor: pointer;">
                                    <td>
                                        <div class="coach-profile-cell">
                                            <div class="coach-avatar" ${avatarStyle}>${avatarText}</div>
                                            <div class="coach-name">${coach.name || 'Unknown Coach'}</div>
                                        </div>
                                    </td>
                                    <td>
                                        ${coach.idVerified ? 
                                            '<span class="verified-badge">Verified</span>' : 
                                            '<span class="unverified-badge">‚è≥ Pending</span>'
                                        }
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            </div>
            
            <div style="margin-top: 30px; padding: 20px; background: #e3f2fd; border-radius: 10px; border-left: 4px solid #0d3b66;">
                <h3 style="color: #0d3b66; margin-bottom: 10px;">üõ°Ô∏è Safety & Verification</h3>
                <p style="color: #666; line-height: 1.6;">
                    All coaches on WordBiz Coaching Academy undergo ID verification for student safety. 
                    Click on any coach to view their full profile and verification details.
                </p>
            </div>
        `;
        
    } catch (error) {
        console.error('‚ùå Error loading coaches:', error);
        container.innerHTML = `
            <div class="feedback error">
                ‚ùå Error loading coaches. Please try refreshing the page.
                <br><br>
                <strong>Error details:</strong> ${error.message}
                <br><br>
                <button class="practice-btn" onclick="loadAndDisplayCoaches()">üîÑ Retry</button>
            </div>
        `;
    }
}

// Load and show coach profile modal
async function showCoachDetailById(coachId) {
    try {
        console.log('üìã Loading coach details for:', coachId);
        const coachDoc = await db.collection('users').doc(coachId).get();
        
        if (coachDoc.exists) {
            const coach = { id: coachDoc.id, ...coachDoc.data() };
            console.log('Coach data loaded:', coach);
            showCoachDetail(coach);
        } else {
            console.error('‚ùå Coach not found');
            alert('Coach profile not found');
        }
    } catch (error) {
        console.error('‚ùå Error loading coach details:', error);
        alert('Unable to load coach details: ' + error.message);
    }
}

// Display coach detail modal
async function showCoachDetail(coach) {
    console.log('Displaying coach modal:', coach.name);
    const modal = document.getElementById('coachDetailModal');
    
    if (!modal) {
        console.error('Coach modal not found!');
        return;
    }
    
    // Update avatar with photo
    const avatar = document.getElementById('modal-coach-avatar');
    if (avatar) {
        if (coach.photoURL) {
            console.log('üñºÔ∏è Setting photo URL:', coach.photoURL);
            avatar.style.backgroundImage = `url('${coach.photoURL}')`;
            avatar.style.backgroundSize = 'cover';
            avatar.style.backgroundPosition = 'center';
            avatar.textContent = '';
        } else {
            console.log('üî§ No photo URL, using initial');
            avatar.style.backgroundImage = 'none';
            avatar.textContent = (coach.name || 'C').charAt(0).toUpperCase();
        }
    }
    
    // Update name
    const nameEl = document.getElementById('modal-coach-name');
    if (nameEl) nameEl.textContent = coach.name || 'Unknown Coach';
    
    // Update status badge
    const statusBadge = document.getElementById('modal-coach-status');
    if (statusBadge) {
        if (coach.idVerified) {
            statusBadge.className = 'status-badge verified';
            statusBadge.textContent = '‚úÖ Verified';
        } else {
            statusBadge.className = 'status-badge pending';
            statusBadge.textContent = '‚è≥ Pending Verification';
        }
    }
    
    // Update email
    const emailEl = document.getElementById('modal-coach-email');
    if (emailEl) emailEl.textContent = coach.email || 'N/A';
    
    // Update organization
    const orgEl = document.getElementById('modal-coach-organization');
    if (orgEl) orgEl.textContent = coach.organization || 'Independent';
    
    // Update joined date
    const joinedEl = document.getElementById('modal-coach-joined');
    if (joinedEl) {
        if (coach.createdAt) {
            const joinDate = coach.createdAt.toDate();
            joinedEl.textContent = joinDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
        } else {
            joinedEl.textContent = 'Recently';
        }
    }
    
    // Show/hide age if available
    const ageRow = document.getElementById('modal-coach-age-row');
    if (ageRow) {
        if (coach.verifiedAge) {
            ageRow.style.display = 'flex';
            const ageEl = document.getElementById('modal-coach-age');
            if (ageEl) ageEl.textContent = coach.verifiedAge + ' years old';
        } else {
            ageRow.style.display = 'none';
        }
    }
    
    // ‚úÖ ADD BOOK COACH BUTTON FOR STUDENTS - Use correct class name
    const coachDetailBody = modal.querySelector('.coach-detail-content');
    
    if (!coachDetailBody) {
        console.error('Coach detail content not found!');
        modal.classList.add('active');
        return;
    }
    
    // Remove any existing book button first
    const existingBookBtn = coachDetailBody.querySelector('.book-coach-container');
    if (existingBookBtn) {
        existingBookBtn.remove();
    }
    
    if (currentUser) {
        try {
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            const userData = userDoc.data();
            
            if (userData && userData.userType === 'student') {
                const bookBtnContainer = document.createElement('div');
                bookBtnContainer.className = 'book-coach-container';
                bookBtnContainer.style.cssText = 'margin-top: 20px; text-align: center; padding: 20px;';
                
                bookBtnContainer.innerHTML = `
                    <button class="practice-btn" onclick="bookCoach('${coach.id}', '${coach.name.replace(/'/g, "\\'")}')" 
                            style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 1.1rem; padding: 15px 30px;">
                        üìö Book This Coach
                    </button>
                `;
                
                coachDetailBody.appendChild(bookBtnContainer);
            }
        } catch (error) {
            console.error('Error checking user type for booking:', error);
        }
    }
    
    // Show modal
    modal.classList.add('active');
    console.log('Modal displayed');
}

// Close coach detail modal
function closeCoachDetailModal() {
    document.getElementById('coachDetailModal').classList.remove('active');
}

// Close modal when clicking outside
document.addEventListener('click', function(event) {
    const modal = document.getElementById('coachDetailModal');
    if (event.target === modal) {
        closeCoachDetailModal();
    }
});

     
// ===== STUDENTS DISPLAY FUNCTIONS =====
async function loadAndDisplayStudents() {
    const container = document.getElementById('students-container');
    
    try {
        container.innerHTML = '<div class="loading">üìö Loading students...</div>';
        
        console.log('üîç Fetching students from Firestore...');
        
        // Fetch all students from Firestore
        const studentsSnapshot = await db.collection('users')
            .where('userType', '==', 'student')
            .get();
        
        console.log('üìä Found students:', studentsSnapshot.size);
        
        if (studentsSnapshot.empty) {
            container.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #666;">
                    <div style="font-size: 3rem; margin-bottom: 20px;">üéì</div>
                    <h3>No students registered yet</h3>
                    <p>Be the first to join as a student!</p>
                </div>
            `;
            return;
        }
        
        const students = [];
        studentsSnapshot.forEach(doc => {
            const data = doc.data();
            console.log('üë§ Student:', doc.id, data.name, data.photoURL);
            students.push({ id: doc.id, ...data });
        });
        
        // Sort students (newest first)
        students.sort((a, b) => {
            if (!a.createdAt) return 1;
            if (!b.createdAt) return -1;
            return b.createdAt.toDate() - a.createdAt.toDate();
        });
        
        // Calculate total students
        const totalStudents = students.length;
        
        // Display stats and table
        container.innerHTML = `
            <!-- Stats Card -->
            <div class="coach-stats">
                <div class="coach-stat-card">
                    <div class="stat-number">${totalStudents}</div>
                    <div class="stat-label">Total Students</div>
                </div>
            </div>
            
            <!-- Students Table -->
            <div class="coaches-table">
                <table>
                    <thead>
                        <tr>
                            <th>üéì Student</th>
                            <th>üÜî Student ID</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${students.map(student => {
                            // Generate Student ID (WB-2025-XXXX)
                            const studentId = `WB-2025-${student.id.slice(-4).toUpperCase()}`;
                            
                            // Determine avatar display
                            let avatarStyle = '';
                            let avatarText = '';
                            
                            if (student.photoURL) {
                                avatarStyle = `style="background-image: url('${student.photoURL}'); background-size: cover; background-position: center;"`;
                                avatarText = '';
                            } else {
                                const initial = (student.name || 'S').charAt(0).toUpperCase();
                                avatarStyle = '';
                                avatarText = initial;
                            }
                            
                            return `
                                <tr onclick="showStudentDetailById('${student.id}')" style="cursor: pointer;">
                                    <td>
                                        <div class="coach-profile-cell">
                                            <div class="coach-avatar" ${avatarStyle}>${avatarText}</div>
                                            <div class="coach-name">${student.name || 'Student'}</div>
                                        </div>
                                    </td>
                                    <td>
                                        <span style="font-family: monospace; background: #e3f2fd; padding: 5px 10px; border-radius: 5px; font-weight: bold; color: #0d3b66;">
                                            ${studentId}
                                        </span>
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            </div>
            
            <div style="margin-top: 30px; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px;">
                <h3 style="color: white; margin-bottom: 10px;">üåü Growing Community</h3>
                <p style="color: rgba(255,255,255,0.95); line-height: 1.6;">
                    Our students are learning from coaches around the world, building vocabulary skills 
                    through interactive quizzes, spelling challenges, and personalized practice sessions.
                    Click on any student to view their full profile.
                </p>
            </div>
        `;
        
    } catch (error) {
        console.error('‚ùå Error loading students:', error);
        container.innerHTML = `
            <div class="feedback error">
                ‚ùå Error loading students. Please try refreshing the page.
                <br><br>
                <strong>Error details:</strong> ${error.message}
                <br><br>
                <button class="practice-btn" onclick="loadAndDisplayStudents()">üîÑ Retry</button>
            </div>
        `;
    }
}
        
// Load and show student profile modal
async function showStudentDetailById(studentId) {
    try {
        console.log('üìã Loading student details for:', studentId);
        const studentDoc = await db.collection('users').doc(studentId).get();
        
        if (studentDoc.exists) {
            const student = { id: studentDoc.id, ...studentDoc.data() };
            console.log('Student data loaded:', student);
            showStudentDetail(student);
        } else {
            console.error('‚ùå Student not found');
            alert('Student profile not found');
        }
    } catch (error) {
        console.error('‚ùå Error loading student details:', error);
        alert('Unable to load student details: ' + error.message);
    }
}

// Display student detail modal
async function showStudentDetail(student) {
    console.log('Displaying student modal:', student.name);
    const modal = document.getElementById('studentDetailModal');
    
    if (!modal) {
        console.error('Student modal not found!');
        return;
    }
    
    // Generate Student ID
    const studentId = `WB-2025-${student.id.slice(-4).toUpperCase()}`;
    
    // Update avatar with photo
    const avatar = document.getElementById('modal-student-avatar');
    if (avatar) {
        if (student.photoURL) {
            console.log('üñºÔ∏è Setting photo URL:', student.photoURL);
            avatar.style.backgroundImage = `url('${student.photoURL}')`;
            avatar.style.backgroundSize = 'cover';
            avatar.style.backgroundPosition = 'center';
            avatar.textContent = '';
        } else {
            console.log('üî§ No photo URL, using initial');
            avatar.style.backgroundImage = 'none';
            avatar.textContent = (student.name || 'S').charAt(0).toUpperCase();
        }
    }
    
    // Update name
    const nameEl = document.getElementById('modal-student-name');
    if (nameEl) nameEl.textContent = student.name || 'Student';
    
    // Update Student ID (both places)
    const idEl = document.getElementById('modal-student-id');
    if (idEl) idEl.textContent = studentId;
    
    const idDisplayEl = document.getElementById('modal-student-id-display');
    if (idDisplayEl) idDisplayEl.textContent = studentId;
    
    // Update email
    const emailEl = document.getElementById('modal-student-email');
    if (emailEl) emailEl.textContent = student.email || 'N/A';
    
    // Update age
    const ageRow = document.getElementById('modal-student-age-row');
    if (ageRow) {
        if (student.age) {
            ageRow.style.display = 'flex';
            const ageEl = document.getElementById('modal-student-age');
            if (ageEl) ageEl.textContent = student.age + ' years old';
        } else {
            ageRow.style.display = 'none';
        }
    }
    
    // Update country
    const countryEl = document.getElementById('modal-student-country');
    if (countryEl) countryEl.textContent = student.country || 'N/A';
    
    // Update joined date
    const joinedEl = document.getElementById('modal-student-joined');
    if (joinedEl) {
        if (student.createdAt) {
            const joinDate = student.createdAt.toDate();
            joinedEl.textContent = joinDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
        } else {
            joinedEl.textContent = 'Recently';
        }
    }
    
    // ‚úÖ ADD RECRUIT BUTTON FOR COACHES - Use correct class name
    const studentDetailBody = modal.querySelector('.coach-detail-content');
    
    if (!studentDetailBody) {
        console.error('Student detail content not found!');
        modal.classList.add('active');
        return;
    }
    
    // Remove any existing recruit button first
    const existingRecruitBtn = studentDetailBody.querySelector('.recruit-student-container');
    if (existingRecruitBtn) {
        existingRecruitBtn.remove();
    }
    
    if (currentUser) {
        try {
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            const userData = userDoc.data();
            
            if (userData && userData.userType === 'coach') {
                const recruitBtnContainer = document.createElement('div');
                recruitBtnContainer.className = 'recruit-student-container';
                recruitBtnContainer.style.cssText = 'margin-top: 20px; text-align: center; padding: 20px;';
                
                recruitBtnContainer.innerHTML = `
                    <button class="practice-btn" onclick="recruitStudent('${student.id}', '${student.name.replace(/'/g, "\\'")}')" 
                            style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); font-size: 1.1rem; padding: 15px 30px;">
                        ‚ûï Recruit to My Class
                    </button>
                `;
                
                studentDetailBody.appendChild(recruitBtnContainer);
            }
        } catch (error) {
            console.error('Error checking user type for recruiting:', error);
        }
    }
    
    // Show modal
    modal.classList.add('active');
    console.log('Modal displayed');
}
        
// Close student detail modal
function closeStudentDetailModal() {
    document.getElementById('studentDetailModal').classList.remove('active');
}

// Close modal when clicking outside
document.addEventListener('click', function(event) {
    const modal = document.getElementById('studentDetailModal');
    if (event.target === modal) {
        closeStudentDetailModal();
    }
});


  // ===== CLASS LOADING FUNCTION =====
async function loadMyClass() {
    if (!currentUser) {
        alert('Please sign in to access your class');
        showAuthModal();
        return;
    }

    try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();

        if (!userData || (!userData.userType === 'student' && userData.userType !== 'coach')) {
            alert('Only students and coaches can access classes');
            navigateTo('home');
            return;
        }

        // Show appropriate view based on user type
        const studentView = document.getElementById('student-class-view');
        const coachView = document.getElementById('coach-class-view');
        
        if (userData.userType === 'student') {
            studentView.style.display = 'block';
            coachView.style.display = 'none';
            await loadStudentClassView();
        } else if (userData.userType === 'coach') {
            studentView.style.display = 'none';
            coachView.style.display = 'block';
            await loadCoachClassView();
        }

    } catch (error) {
        console.error('Error loading class:', error);
        alert('Failed to load class information');
    }
}

// ===== STUDENT CLASS VIEW =====
async function loadStudentClassView() {
    const container = document.getElementById('student-class-info');
    
    try {
        container.innerHTML = '<div class="loading">Loading your class...</div>';
        
        // Check if student has a class
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        
        if (!userData.classId) {
            container.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 3rem; margin-bottom: 20px;">üìö</div>
                    <h3>You're not in a class yet</h3>
                    <p style="color: #666; margin: 20px 0;">
                        Browse available coaches and book one to join their class!
                    </p>
                    <button class="practice-btn" onclick="navigateTo('coaches')">
                        Browse Coaches
                    </button>
                </div>
            `;
            return;
        }
        
        // Load class info
        const classDoc = await db.collection('classes').doc(userData.classId).get();
        
        if (!classDoc.exists) {
            container.innerHTML = `
                <div class="feedback error">
                    Class not found. Please contact your coach.
                </div>
            `;
            return;
        }
        
        const classData = classDoc.data();
        
        // Load coach info
        const coachDoc = await db.collection('users').doc(classData.coachId).get();
        const coachData = coachDoc.data();
        
        // Load announcements
        const announcementsSnapshot = await db.collection('classes')
            .doc(userData.classId)
            .collection('announcements')
            .orderBy('createdAt', 'desc')
            .limit(5)
            .get();
        
        const announcements = [];
        announcementsSnapshot.forEach(doc => {
            announcements.push({ id: doc.id, ...doc.data() });
        });
        
        // ‚úÖ FIXED: Only show live session if it's truly active AND has a sessionId
        const liveSessionHtml = (classData.liveSessionActive === true && classData.liveSessionId) ? `
            <div id="live-session-join-container" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); padding: 25px; border-radius: 15px; text-align: center; margin-bottom: 30px; box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);">
                <h3 style="color: white; margin-bottom: 15px; font-size: 1.5rem;">üé• Live Session Active!</h3>
                <p style="color: rgba(255,255,255,0.95); margin-bottom: 20px;">Your coach has started a live session. Join now to participate!</p>
                <button id="join-session-btn" class="practice-btn" onclick="joinLiveSession()" style="background: white; color: #28a745; font-size: 1.2rem; font-weight: bold; padding: 15px 40px;">
                    üé§ Join Live Session
                </button>
            </div>
            
            <!-- Live Session Active UI (Hidden until joined) -->
            <div id="student-live-session-active" style="display: none;">
                <div style="background: white; padding: 20px; border-radius: 10px; border: 2px solid #28a745; margin-bottom: 30px;">
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                            <h3 style="color: #28a745; margin: 0; flex-shrink: 0;">üé• In Live Session</h3>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                <button id="student-toggle-mic-btn" class="practice-btn" onclick="toggleMicrophone()" style="background: #28a745; white-space: nowrap; padding: 10px 20px;">
                                    üé§ Mute
                                </button>
                                <button class="practice-btn" onclick="endLiveSession()" style="background: #dc3545; white-space: nowrap; padding: 10px 20px;">
                                    ‚ùå Leave Session
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                        <h4 style="color: #0d3b66; margin-bottom: 15px;">üë• Participants</h4>
                        <div id="student-session-participants-list"></div>
                    </div>
                    
                    <div id="remote-audio-container" style="display: none;"></div>
                </div>
            </div>
        ` : '';
        
        // Display class info
        container.innerHTML = `
            ${liveSessionHtml}
            
            <div class="dashboard-section">
                <h3 style="color: #0d3b66; margin-bottom: 20px;">üë®‚Äçüè´ Your Coach</h3>
                <div style="background: white; padding: 20px; border-radius: 10px; border: 2px solid #0d3b66; margin-bottom: 30px;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div class="coach-avatar" style="width: 60px; height: 60px; ${coachData.photoURL ? `background-image: url('${coachData.photoURL}'); background-size: cover;` : ''}">
                            ${!coachData.photoURL ? (coachData.name || 'C').charAt(0).toUpperCase() : ''}
                        </div>
                        <div>
                            <h3 style="margin: 0; color: #0d3b66;">${coachData.name || 'Coach'}</h3>
                            <p style="margin: 5px 0 0 0; color: #666;">${coachData.email}</p>
                        </div>
                    </div>
                </div>
                
                <h3 style="color: #0d3b66; margin-bottom: 20px;">üì¢ Recent Announcements</h3>
                ${announcements.length > 0 ? `
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        ${announcements.map(ann => {
                            let nextClassHtml = '';
                            if (ann.nextClassDate) {
                                const classDate = new Date(ann.nextClassDate);
                                const options = { 
                                    year: 'numeric', 
                                    month: 'long', 
                                    day: 'numeric', 
                                    hour: 'numeric', 
                                    minute: '2-digit',
                                    hour12: true 
                                };
                                const formattedDate = classDate.toLocaleString('en-US', options).toUpperCase();
                                nextClassHtml = `
                                    <p style="margin: 10px 0 0 0; color: #28a745; font-weight: bold;">
                                        üé• Next Class: ${formattedDate}
                                    </p>
                                `;
                            }
                            
                            return `
                                <div style="background: white; padding: 20px; border-radius: 10px; border-left: 4px solid #0d3b66;">
                                    <h4 style="margin: 0 0 10px 0; color: #0d3b66;">${ann.title}</h4>
                                    <p style="margin: 0; color: #666; white-space: pre-wrap;">${ann.message}</p>
                                    ${nextClassHtml}
                                    <p style="margin: 10px 0 0 0; color: #999; font-size: 0.9rem;">
                                        ${ann.createdAt ? ann.createdAt.toDate().toLocaleString() : 'Recently'}
                                    </p>
                                </div>
                            `;
                        }).join('')}
                    </div>
                ` : `
                    <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 10px;">
                        <p style="color: #666;">No announcements yet</p>
                    </div>
                `}
            </div>
        `;
        
        // Set up live session listener for real-time updates
        liveSessionId = userData.classId;
        
        // ‚úÖ FIXED: Listen for session status changes with proper validation
        db.collection('classes').doc(userData.classId).onSnapshot(doc => {
            if (doc.exists) {
                const data = doc.data();
                
                // ‚úÖ Check if session is TRULY active (both flags must be true)
                const sessionIsActive = data.liveSessionActive === true && data.liveSessionId != null;
                
                const joinContainer = document.getElementById('live-session-join-container');
                const activeSessionUI = document.getElementById('student-live-session-active');
                
                // If session just started and we're not in it yet
                if (sessionIsActive && !liveSessionActive) {
                    // Show join button if it doesn't exist
                    if (!joinContainer) {
                        // Reload the view to show the join button
                        loadStudentClassView();
                    }
                }
                
                // If session ended while we were in it or viewing
                if (!sessionIsActive && (liveSessionActive || joinContainer)) {
                    if (liveSessionActive) {
                        alert('üì¢ The live session has ended');
                        endLiveSession();
                    }
                    // Reload to remove session UI
                    loadStudentClassView();
                }
            }
        });
        
    } catch (error) {
        console.error('Error loading student class view:', error);
        container.innerHTML = `
            <div class="feedback error">
                Failed to load class information: ${error.message}
            </div>
        `;
    }
}

// ===== COACH CLASS VIEW =====
async function loadCoachClassView() {
    try {
        // Get or create coach's class
        const classQuery = await db.collection('classes')
            .where('coachId', '==', currentUser.uid)
            .limit(1)
            .get();
        
        if (classQuery.empty) {
            // Create class for coach
            const classRef = await db.collection('classes').add({
                coachId: currentUser.uid,
                coachName: currentUser.displayName || 'Coach',
                coachEmail: currentUser.email,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                studentCount: 0,
                liveSessionActive: false,
                liveSessionId: null,
                sessionCount: 0
            });
            
            // Update user with classId
            await db.collection('users').doc(currentUser.uid).update({
                classId: classRef.id
            });
            
            myClass = {
                id: classRef.id,
                coachId: currentUser.uid,
                coachName: currentUser.displayName || 'Coach',
                coachEmail: currentUser.email,
                studentCount: 0,
                liveSessionActive: false,
                liveSessionId: null
            };
        } else {
            const classDoc = classQuery.docs[0];
            myClass = { id: classDoc.id, ...classDoc.data() };
            
            // Update user with classId if not set
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            if (!userDoc.data().classId) {
                await db.collection('users').doc(currentUser.uid).update({
                    classId: myClass.id
                });
            }
        }
        
        isCoach = true; // Set coach flag
        
        // Load students
        await loadClassStudents();
        
        // Load announcements
        await loadClassAnnouncements();
        
        // Update stats
        updateCoachClassStats();
        
        // ‚úÖ CHECK IF SESSION IS ACTIVE AND ALLOW COACH TO REJOIN
        if (myClass.liveSessionActive && myClass.liveSessionId) {
            console.log('‚ÑπÔ∏è Active session detected - showing rejoin option');
            
            // Update button text to show rejoin option
            const startBtn = document.getElementById('start-session-btn');
            if (startBtn) {
                startBtn.textContent = 'üîÑ Rejoin Live Session';
                startBtn.style.background = '#17a2b8'; // Blue color for rejoin
            }
        }
        
    } catch (error) {
        console.error('Error loading coach class view:', error);
        alert('Failed to load class management: ' + error.message);
    }
}

        
async function loadClassStudents() {
    try {
        const studentsSnapshot = await db.collection('users')
            .where('classId', '==', myClass.id)
            .where('userType', '==', 'student') // ‚úÖ Only get students, not coaches
            .get();
        
        classStudents = [];
        studentsSnapshot.forEach(doc => {
            classStudents.push({ id: doc.id, ...doc.data() });
        });
        
        displayClassStudents();
    } catch (error) {
        console.error('Error loading class students:', error);
    }
}

async function loadClassAnnouncements() {
    try {
        const announcementsSnapshot = await db.collection('classes')
            .doc(myClass.id)
            .collection('announcements')
            .orderBy('createdAt', 'desc')
            .get();
        
        classAnnouncements = [];
        announcementsSnapshot.forEach(doc => {
            classAnnouncements.push({ id: doc.id, ...doc.data() });
        });
        
        displayClassAnnouncements();
    } catch (error) {
        console.error('Error loading announcements:', error);
    }
}

function displayClassStudents() {
    const container = document.getElementById('coach-students-list');
    
    if (classStudents.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 10px;">
                <p style="color: #666;">No students in your class yet</p>
                <button class="practice-btn" onclick="navigateTo('students')" style="margin-top: 15px;">
                    Browse Students
                </button>
            </div>
        `;
        return;
    }
    
    container.innerHTML = `
        <div style="display: grid; gap: 15px;">
            ${classStudents.map(student => `
                <div style="background: white; padding: 15px; border-radius: 10px; border: 2px solid #0d3b66; display: flex; align-items: center; gap: 15px;">
                    <div class="coach-avatar" style="width: 50px; height: 50px; ${student.photoURL ? `background-image: url('${student.photoURL}'); background-size: cover;` : ''}">
                        ${!student.photoURL ? (student.name || 'S').charAt(0).toUpperCase() : ''}
                    </div>
                    <div style="flex: 1;">
                        <h4 style="margin: 0; color: #0d3b66;">${student.name || 'Student'}</h4>
                        <p style="margin: 5px 0 0 0; color: #666; font-size: 0.9rem;">${student.email}</p>
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}

function displayClassAnnouncements() {
    const container = document.getElementById('coach-announcements-list');
    
    if (classAnnouncements.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 10px;">
                <p style="color: #666;">No announcements yet</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = `
        <div style="display: grid; gap: 15px;">
            ${classAnnouncements.map(ann => {
                let nextClassHtml = '';
                if (ann.nextClassDate) {
                    const classDate = new Date(ann.nextClassDate);
                    const options = { 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric', 
                        hour: 'numeric', 
                        minute: '2-digit',
                        hour12: true 
                    };
                    const formattedDate = classDate.toLocaleString('en-US', options).toUpperCase();
                    nextClassHtml = `
                        <p style="margin: 10px 0 0 0; color: #28a745; font-weight: bold;">
                            üé• Next Class: ${formattedDate}
                        </p>
                    `;
                }
                
                return `
                    <div style="background: white; padding: 20px; border-radius: 10px; border-left: 4px solid #0d3b66;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <h4 style="margin: 0; color: #0d3b66;">${ann.title}</h4>
                            <button onclick="deleteAnnouncement('${ann.id}')" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">
                                üóëÔ∏è
                            </button>
                        </div>
                        <p style="margin: 10px 0; color: #666; white-space: pre-wrap;">${ann.message}</p>
                        ${nextClassHtml}
                        <p style="margin: 10px 0 0 0; color: #999; font-size: 0.9rem;">
                            ${ann.createdAt ? ann.createdAt.toDate().toLocaleString() : 'Recently'}
                        </p>
                    </div>
                `;
            }).join('')}
        </div>
    `;
}

function updateCoachClassStats() {
    document.getElementById('class-student-count').textContent = classStudents.length;
    document.getElementById('class-announcement-count').textContent = classAnnouncements.length;
    document.getElementById('class-session-count').textContent = myClass ? (myClass.sessionCount || 0) : '0';
}
function showAddAnnouncementModal() {
    document.getElementById('announcementModal').classList.add('active');
}

function closeAnnouncementModal() {
    document.getElementById('announcementModal').classList.remove('active');
    document.getElementById('announcement-form').reset();
    document.getElementById('announcement-error').style.display = 'none';
}

async function handleAddAnnouncement(event) {
    event.preventDefault();
    
    const title = document.getElementById('announcement-title').value.trim();
    const message = document.getElementById('announcement-message').value.trim();
    const classDate = document.getElementById('announcement-class-date').value;
    const errorDiv = document.getElementById('announcement-error');
    
    if (!title || !message) {
        errorDiv.textContent = 'Please fill in all required fields';
        errorDiv.style.display = 'block';
        return;
    }
    
    try {
        await db.collection('classes')
            .doc(myClass.id)
            .collection('announcements')
            .add({
                title,
                message,
                nextClassDate: classDate || null,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });
        
        closeAnnouncementModal();
        await loadClassAnnouncements();
        updateCoachClassStats();
        
        alert('‚úÖ Announcement posted successfully!');
    } catch (error) {
        console.error('Error posting announcement:', error);
        errorDiv.textContent = 'Failed to post announcement: ' + error.message;
        errorDiv.style.display = 'block';
    }
}

async function deleteAnnouncement(announcementId) {
    if (!confirm('Are you sure you want to delete this announcement?')) {
        return;
    }
    
    try {
        await db.collection('classes')
            .doc(myClass.id)
            .collection('announcements')
            .doc(announcementId)
            .delete();
        
        await loadClassAnnouncements();
        updateCoachClassStats();
        
        alert('‚úÖ Announcement deleted');
    } catch (error) {
        console.error('Error deleting announcement:', error);
        alert('Failed to delete announcement');
    }
}

// ICE servers for WebRTC connection
const iceServers = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
    ]
};

// ===== START LIVE SESSION (COACH ONLY) =====
async function startLiveSession() {
    if (!currentUser || !myClass) {
        alert('Unable to start session');
        return;
    }
    
    try {
        console.log('üé§ Starting live session...');
        
        // ‚úÖ CRITICAL: Clean up any existing session first
        if (localAudioStream) {
            console.log('‚ö†Ô∏è Cleaning up existing audio stream');
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
        
        if (peerConnections.size > 0) {
            console.log('‚ö†Ô∏è Cleaning up existing peer connections');
            peerConnections.forEach(pc => pc.close());
            peerConnections.clear();
        }
        
        if (liveSessionListener) {
            console.log('‚ö†Ô∏è Cleaning up existing listener');
            liveSessionListener();
            liveSessionListener = null;
        }
        
        // ‚úÖ CHECK IF SESSION IS ALREADY ACTIVE (REJOIN SCENARIO)
        const isRejoin = myClass.liveSessionActive && myClass.liveSessionId;
        
        // Get microphone permission with fresh stream
        console.log('üé§ Requesting microphone access...');
        localAudioStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            } 
        });
        
        // ‚úÖ START WITH MIC MUTED
        localAudioStream.getAudioTracks().forEach(track => {
            track.enabled = false; // Start muted
        });
        isMicMuted = true;
        
        console.log('‚úÖ Microphone access granted (MUTED by default)');
        
        if (!isRejoin) {
            // Starting new session
            liveSessionId = myClass.id;
            
            const currentSessionCount = myClass.sessionCount || 0;
            
            await db.collection('classes').doc(myClass.id).update({
                liveSessionActive: true,
                liveSessionId: liveSessionId,
                liveSessionStartedAt: firebase.firestore.FieldValue.serverTimestamp(),
                liveSessionHost: currentUser.uid,
                sessionCount: currentSessionCount + 1
            });
            
            console.log('‚úÖ New session started');
            myClass.sessionCount = currentSessionCount + 1;
        } else {
            // Rejoining existing session
            liveSessionId = myClass.liveSessionId;
            console.log('üîÑ Rejoining existing session:', liveSessionId);
        }
        
        // Add/update coach as participant
       await db.collection('classes')
            .doc(myClass.id)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .set({
                userId: currentUser.uid,
                name: currentUser.displayName || 'Coach',
                email: currentUser.email,
                photoURL: currentUser.photoURL || null,
                joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                micMuted: true,
                coachMuted: false,
                isCoach: true // ‚úÖ Add coach flag
            });
        
        liveSessionActive = true;
        isCoach = true;
        
        // ‚úÖ Store coach flag in participant data
        await db.collection('classes')
            .doc(myClass.id)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .update({
                isCoach: true
            });
        
        // Show live session UI for COACH
        const startBtn = document.getElementById('start-session-btn');
        const liveSessionContainer = document.getElementById('coach-live-session-active');
        
        if (startBtn) startBtn.style.display = 'none';
        if (liveSessionContainer) liveSessionContainer.style.display = 'block';
        
        // ‚úÖ Set mic button to muted state
        const micBtn = document.getElementById('coach-toggle-mic-btn');
        if (micBtn) {
            micBtn.textContent = 'üîá Unmute';
            micBtn.style.background = '#dc3545';
        }
        
        // Update session count in UI
        updateCoachClassStats();
        
        // Listen for participants joining
        listenForSessionParticipants();
        
        const message = isRejoin ? '‚úÖ Rejoined live session! (Mic is muted)' : '‚úÖ Live session started! (Mic is muted - click Unmute to speak)';
        alert(message);
        
        console.log('‚úÖ Session start complete');
        
    } catch (error) {
        console.error('‚ùå Error starting live session:', error);
        
        if (error.name === 'NotAllowedError') {
            alert('‚ùå Microphone access denied. Please allow microphone access and try again.');
        } else if (error.name === 'NotFoundError') {
            alert('‚ùå No microphone found. Please connect a microphone and try again.');
        } else {
            alert('Failed to start session: ' + error.message);
        }
        
        // Cleanup on error
        if (localAudioStream) {
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
    }
}
        
// ===== JOIN LIVE SESSION (STUDENT) =====
async function joinLiveSession() {
    if (!currentUser) {
        alert('Please sign in to join the session');
        return;
    }
    
    try {
        console.log('üé§ Joining live session...');
        
        // ‚úÖ Set cleanup flag
        isCleaningUp = true;
        
        // ‚úÖ CRITICAL: Clean up any existing session first
        if (localAudioStream) {
            console.log('‚ö†Ô∏è Cleaning up existing audio stream');
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
        
        if (peerConnections.size > 0) {
            console.log('‚ö†Ô∏è Cleaning up existing peer connections');
            peerConnections.forEach(pc => pc.close());
            peerConnections.clear();
        }
        
        if (liveSessionListener) {
            console.log('‚ö†Ô∏è Cleaning up existing listener');
            liveSessionListener();
            liveSessionListener = null;
        }
        
        // Clear pending ICE candidates
        pendingIceCandidates.clear();
        
        // Get user data
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        
        if (!userData.classId) {
            alert('You are not enrolled in a class');
            isCleaningUp = false;
            return;
        }
        
        liveSessionId = userData.classId;
        
        // Check if session is actually active
        const classDoc = await db.collection('classes').doc(userData.classId).get();
        const classData = classDoc.data();
        
        if (!classData.liveSessionActive || !classData.liveSessionId) {
            alert('‚ùå This session is no longer active');
            isCleaningUp = false;
            return;
        }
        
        console.log('‚úÖ Session is active, joining...');
        
        // ‚úÖ Check if we're already in the participants list (rejoining scenario)
        const existingParticipant = await db.collection('classes')
            .doc(userData.classId)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .get();

        if (existingParticipant.exists) {
            console.log('üîÑ Rejoining - cleaning up old participant entry and signaling');
            
            // ‚úÖ Clean up old signaling messages FIRST
            await cleanupOldSignalingMessages(currentUser.uid);
            
            // Delete old entry to force clean reconnection
            await db.collection('classes')
                .doc(userData.classId)
                .collection('sessionParticipants')
                .doc(currentUser.uid)
                .delete();
            
            // ‚úÖ Wait for coach to detect removal and clean up
            console.log('‚è≥ Waiting 5 seconds for complete cleanup...');
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // ‚úÖ Clean up signaling AGAIN (in case coach sent messages during deletion)
            await cleanupOldSignalingMessages(currentUser.uid);
        }
        
        // Get microphone permission with fresh stream
        console.log('üé§ Requesting microphone access...');
        localAudioStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            } 
        });
        
        // ‚úÖ START WITH MIC MUTED
        localAudioStream.getAudioTracks().forEach(track => {
            track.enabled = false; // Start muted
        });
        isMicMuted = true;
        
        console.log('‚úÖ Microphone access granted (MUTED by default)');
        
        // ‚úÖ Clear cleanup flag BEFORE starting listeners
        isCleaningUp = false;
        
        // Add to session participants (this triggers coach to create new connection)
        console.log('üìù Adding to session participants...');
        await db.collection('classes')
            .doc(userData.classId)
            .collection('sessionParticipants')
            .doc(currentUser.uid)
            .set({
                userId: currentUser.uid,
                name: userData.name || 'Student',
                email: userData.email,
                photoURL: userData.photoURL || null,
                joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                micMuted: true,
                coachMuted: false,
                isCoach: false // ‚úÖ Add student flag
            });
        
        console.log('‚úÖ Added to session participants');
        console.log('‚úÖ Added to session participants as STUDENT (isCoach: false)');
        console.log('üîç My role - isCoach:', isCoach, 'currentUser.uid:', currentUser.uid);
        liveSessionActive = true;
        
        // Hide join button and show active session UI
        const joinContainer = document.getElementById('live-session-join-container');
        const activeSessionUI = document.getElementById('student-live-session-active');
        
        if (joinContainer) joinContainer.style.display = 'none';
        if (activeSessionUI) activeSessionUI.style.display = 'block';
        
        // ‚úÖ Set mic button to muted state
        const micBtn = document.getElementById('student-toggle-mic-btn');
        if (micBtn) {
            micBtn.textContent = 'üîá Unmute';
            micBtn.style.background = '#dc3545';
        }
        
        // Listen for participants (this will trigger coach's offer)
        listenForSessionParticipants();
        
        alert('‚úÖ Joined live session! (Mic is muted - click Unmute when ready to speak)');
        
        console.log('‚úÖ Joined live session successfully');
        
    } catch (error) {
        console.error('‚ùå Error joining session:', error);
        
        // ‚úÖ Clear cleanup flag on error
        isCleaningUp = false;
        
        let errorMessage = 'Failed to join session. ';
        
        if (error.name === 'NotAllowedError') {
            errorMessage += 'Microphone access was denied. Please allow microphone access in your browser settings and try again.';
        } else if (error.name === 'NotFoundError') {
            errorMessage += 'No microphone found. Please connect a microphone and try again.';
        } else if (error.message) {
            errorMessage += error.message;
        } else {
            errorMessage += 'Please check your microphone permissions and try again.';
        }
        
        alert(errorMessage);
        
        // Cleanup on error
        if (localAudioStream) {
            localAudioStream.getTracks().forEach(track => track.stop());
            localAudioStream = null;
        }
        
        // Remove from participants if we added ourselves
        try {
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            const userData = userDoc.data();
            if (userData.classId) {
                await db.collection('classes')
                    .doc(userData.classId)
                    .collection('sessionParticipants')
                    .doc(currentUser.uid)
                    .delete();
            }
        } catch (cleanupError) {
            console.error('Error cleaning up after failed join:', cleanupError);
        }
    }
}

   
// ===== LISTEN FOR SESSION PARTICIPANTS =====
function listenForSessionParticipants() {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üëÇ Setting up participant listener for class:', classId);
    
    liveSessionListener = db.collection('classes')
        .doc(classId)
        .collection('sessionParticipants')
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const participant = change.doc.data();
                    
                    console.log('‚ûï Participant added:', participant.name, participant.userId);
                    
                    // Skip ourselves
                    if (participant.userId === currentUser.uid) {
                        console.log('   ‚≠êÔ∏è Skipping self');
                        sessionParticipants.set(participant.userId, participant);
                        return;
                    }
                    
                    // ‚úÖ EVERYONE CREATES CONNECTIONS TO EVERYONE
                    if (isCoach) {
                        // Coach initiates all connections
                        console.log('üëë Coach creating connection to:', participant.name);
                        await createPeerConnection(participant.userId, participant, true);
                    } else {
                        // Student connecting to others
                        console.log('üë• Student needs to connect to:', participant.name);
                        
                        // Check if participant is coach
                        if (participant.isCoach) {
                            console.log('   ‚Üí Participant is COACH, waiting for their offer');
                            // Coach will initiate, we wait
                        } else {
                            console.log('   ‚Üí Participant is STUDENT, checking who initiates...');
                            // Student-to-student: Compare UIDs to avoid duplicate connections
                            if (currentUser.uid < participant.userId) {
                                console.log('   ‚Üí ‚úÖ I INITIATE (my UID is lower)');
                                await createPeerConnection(participant.userId, participant, true);
                            } else {
                                console.log('   ‚Üí ‚è≥ THEY INITIATE (their UID is lower), waiting for offer');
                                // They will initiate, we wait for offer
                            }
                        }
                    }
                    
                    sessionParticipants.set(participant.userId, participant);
                }
                
                if (change.type === 'removed') {
                    const participant = change.doc.data();
                    console.log('‚ûñ Participant removed:', participant.name);
                    
                    closePeerConnection(participant.userId);
                    sessionParticipants.delete(participant.userId);
                }
                
                if (change.type === 'modified') {
                    const participant = change.doc.data();
                    sessionParticipants.set(participant.userId, participant);
                    
                    // ‚úÖ Check if coach muted/unmuted this student
                    if (participant.userId === currentUser.uid && !isCoach) {
                        const wasCoachMuted = coachMutedMe;
                        coachMutedMe = participant.coachMuted || false;
                        
                        if (coachMutedMe && !wasCoachMuted) {
                            console.log('üîá Coach muted you');
                            if (localAudioStream) {
                                const audioTrack = localAudioStream.getAudioTracks()[0];
                                if (audioTrack) {
                                    audioTrack.enabled = false;
                                    isMicMuted = true;
                                    
                                    // Update all peer connections
                                    peerConnections.forEach((pc) => {
                                        const senders = pc.getSenders();
                                        senders.forEach(sender => {
                                            if (sender.track && sender.track.kind === 'audio') {
                                                sender.track.enabled = false;
                                            }
                                        });
                                    });
                                    
                                    const btn = document.getElementById('student-toggle-mic-btn');
                                    if (btn) {
                                        btn.textContent = 'üîá Unmute';
                                        btn.style.background = '#dc3545';
                                    }
                                }
                            }
                            alert('üîá Your coach has muted you');
                        } else if (!coachMutedMe && wasCoachMuted) {
                            console.log('üîä Coach unmuted you');
                            alert('üîä Your coach has unmuted you. You can now speak.');
                        }
                    }
                }
            });
            
            updateParticipantsList();
        });
    
    // Listen for WebRTC signaling
    listenForSignaling();
}


// ===== CHECK IF USER IS COACH =====
async function checkIfUserIsCoach(userId) {
    try {
        const classId = myClass ? myClass.id : liveSessionId;
        const classDoc = await db.collection('classes').doc(classId).get();
        const classData = classDoc.data();
        
        // Check if this user is the coach of the class
        return classData && classData.coachId === userId;
    } catch (error) {
        console.error('Error checking if user is coach:', error);
        return false;
    }
}


// ===== CONNECTION HEALTH CHECK WITH AUDIO VERIFICATION =====
function startConnectionHealthCheck(userId, peerConnection, participant) {
    // Clear any existing check
    if (connectionHealthChecks.has(userId)) {
        clearInterval(connectionHealthChecks.get(userId));
    }
    
    let failureCount = 0;
    const MAX_FAILURES = 3;
    
    const checkInterval = setInterval(async () => {
        if (!peerConnection || peerConnection.connectionState === 'closed') {
            clearInterval(checkInterval);
            connectionHealthChecks.delete(userId);
            return;
        }
        
        const state = peerConnection.connectionState;
        const iceState = peerConnection.iceConnectionState;
        
        console.log(`üè• Health check ${participant.name}: connection=${state}, ice=${iceState}`);
        
        // Check for failures
        if (state === 'failed' || iceState === 'failed' || iceState === 'disconnected') {
            failureCount++;
            console.warn(`‚ö†Ô∏è Connection issue detected for ${participant.name} (${failureCount}/${MAX_FAILURES})`);
            
            if (failureCount >= MAX_FAILURES) {
                console.error(`‚ùå Connection health check failed ${MAX_FAILURES} times for ${participant.name}, reconnecting...`);
                clearInterval(checkInterval);
                connectionHealthChecks.delete(userId);
                
                // Close and recreate connection
                peerConnection.close();
                peerConnections.delete(userId);
                
                // Remove audio element
                const audioElement = document.getElementById(`audio_${userId}`);
                if (audioElement) {
                    audioElement.pause();
                    audioElement.srcObject = null;
                    audioElement.remove();
                }
                
                if (sessionParticipants.has(userId) && !isCleaningUp) {
                    setTimeout(() => {
                        console.log('üîÑ Recreating connection to:', participant.name);
                        createPeerConnection(userId, participant, isCoach);
                    }, 2000);
                }
            }
        } else if (state === 'connected' && iceState === 'connected') {
            // Connection is good, reset failure count
            if (failureCount > 0) {
                console.log(`‚úÖ Connection recovered for ${participant.name}`);
                failureCount = 0;
            }
            
            // ‚úÖ VERIFY AUDIO IS ACTUALLY FLOWING
            const audioElement = document.getElementById(`audio_${userId}`);
            if (audioElement && audioElement.srcObject) {
                const stream = audioElement.srcObject;
                const audioTracks = stream.getAudioTracks();
                
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    if (track.readyState === 'ended') {
                        console.error(`‚ùå Audio track ended for ${participant.name}, recreating connection`);
                        failureCount = MAX_FAILURES; // Force reconnection
                    }
                } else {
                    console.warn(`‚ö†Ô∏è No audio tracks for ${participant.name}`);
                }
            }
        }
    }, 5000); // Check every 5 seconds
    
    connectionHealthChecks.set(userId, checkInterval);
    console.log(`‚úÖ Health monitoring started for ${participant.name}`);
}

        
// ===== CREATE PEER CONNECTION WITH HEALTH MONITORING =====
async function createPeerConnection(userId, participant, isInitiator = true) {
    try {
        console.log('üîó Creating peer connection with:', participant.name, 'isInitiator:', isInitiator);
        
        // Stop any existing health check
        if (connectionHealthChecks.has(userId)) {
            clearInterval(connectionHealthChecks.get(userId));
            connectionHealthChecks.delete(userId);
        }
        
        // Ensure we have a local audio stream
        if (!localAudioStream || localAudioStream.getTracks().length === 0) {
            console.error('‚ùå No local audio stream available! Re-requesting...');
            try {
                localAudioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                localAudioStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMicMuted;
                });
                console.log('‚úÖ Re-acquired microphone access');
            } catch (error) {
                console.error('‚ùå Failed to re-acquire microphone:', error);
                throw error;
            }
        }
        
        // Close existing connection if it exists
        if (peerConnections.has(userId)) {
            console.log('‚ö†Ô∏è Closing existing connection before creating new one');
            const oldPc = peerConnections.get(userId);
            oldPc.close();
            peerConnections.delete(userId);
            
            const oldAudio = document.getElementById(`audio_${userId}`);
            if (oldAudio) {
                oldAudio.pause();
                oldAudio.srcObject = null;
                oldAudio.remove();
            }
        }
        
        const peerConnection = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10
        });
        
        // ‚úÖ CAPTURE CURRENT MIC STATE BEFORE ADDING TRACKS
        const currentMicState = isMicMuted;
        console.log('üì∏ Captured mic state:', currentMicState ? 'MUTED' : 'UNMUTED');
        
        // Add local audio tracks
        console.log('üé§ Adding local audio tracks to peer connection');
        localAudioStream.getTracks().forEach(track => {
            // ‚úÖ Set to ACTUAL current state, not forced
            track.enabled = !currentMicState;
            console.log('   ‚úÖ Track added:', track.kind, 'enabled:', track.enabled);
            peerConnection.addTrack(track, localAudioStream);
        });
        
        // Handle incoming tracks
        peerConnection.ontrack = (event) => {
            console.log('üì• Received track from:', participant.name);
            console.log('   Track kind:', event.track.kind);
            console.log('   Track enabled:', event.track.enabled);
            console.log('   Track readyState:', event.track.readyState);
            
            if (event.streams.length === 0) {
                console.error('‚ùå No streams in track event!');
                return;
            }
            
            const remoteStream = event.streams[0];
            console.log('   Stream audio tracks:', remoteStream.getAudioTracks().length);
            
            remoteStreams.set(userId, remoteStream);
            
            // Remove old audio element if exists
            const oldAudio = document.getElementById(`audio_${userId}`);
            if (oldAudio) {
                console.log('üóëÔ∏è Removing old audio element');
                oldAudio.pause();
                oldAudio.srcObject = null;
                oldAudio.remove();
            }
            
            // Create new audio element
            setTimeout(() => {
                const audioElement = document.createElement('audio');
                audioElement.id = `audio_${userId}`;
                audioElement.autoplay = true;
                audioElement.playsInline = true;
                audioElement.volume = 1.0;
                audioElement.srcObject = remoteStream;
                
                audioElement.onloadedmetadata = () => {
                    console.log('‚úÖ Audio metadata loaded for:', participant.name);
                };
                
                audioElement.onplay = () => {
                    console.log('‚úÖ Audio started playing for:', participant.name);
                };
                
                audioElement.onerror = (e) => {
                    console.error('‚ùå Audio element error:', e);
                };
                
                let container = document.getElementById('remote-audio-container');
                if (!container) {
                    console.warn('‚ö†Ô∏è remote-audio-container not found, creating it');
                    container = document.createElement('div');
                    container.id = 'remote-audio-container';
                    container.style.display = 'none';
                    document.body.appendChild(container);
                }
                container.appendChild(audioElement);
                
                console.log('‚úÖ Audio element created and added');
                
                // Force play
                const playPromise = audioElement.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('‚úÖ Audio playing successfully for:', participant.name);
                        })
                        .catch(err => {
                            console.error('‚ùå Error playing audio:', err);
                            if (err.name === 'NotAllowedError') {
                                alert(`Click OK to enable audio from ${participant.name}`);
                                audioElement.play()
                                    .then(() => console.log('‚úÖ Audio playing after user interaction'))
                                    .catch(e => console.error('‚ùå Still failed:', e));
                            }
                        });
                }
            }, 100);
        };
        
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('üßä Sending ICE candidate to:', participant.name);
                sendIceCandidate(userId, event.candidate);
            }
        };
        
        peerConnection.onconnectionstatechange = () => {
            console.log(`Connection state with ${participant.name}:`, peerConnection.connectionState);
            
            if (peerConnection.connectionState === 'connected') {
                console.log('‚úÖ Peer connection established with:', participant.name);
                
                // ‚úÖ START HEALTH MONITORING
                startConnectionHealthCheck(userId, peerConnection, participant);
                
            } else if (peerConnection.connectionState === 'failed') {
                console.error('‚ùå Connection failed with:', participant.name);
                
                // Stop health check
                if (connectionHealthChecks.has(userId)) {
                    clearInterval(connectionHealthChecks.get(userId));
                    connectionHealthChecks.delete(userId);
                }
                
                // Attempt reconnection after delay
                setTimeout(() => {
                    if (sessionParticipants.has(userId)) {
                        console.log('üîÑ Attempting to reconnect with:', participant.name);
                        createPeerConnection(userId, participant, isCoach);
                    }
                }, 3000);
                
            } else if (peerConnection.connectionState === 'disconnected') {
                console.warn('‚ö†Ô∏è Connection disconnected with:', participant.name);
            }
        };
        
        peerConnection.oniceconnectionstatechange = () => {
            console.log(`ICE connection state with ${participant.name}:`, peerConnection.iceConnectionState);
            
            if (peerConnection.iceConnectionState === 'failed') {
                console.error('‚ùå ICE connection failed, triggering restart');
                peerConnection.restartIce();
            }
        };
        
        peerConnections.set(userId, peerConnection);
        
        if (isInitiator) {
            console.log('üì§ Creating and sending offer to:', participant.name);
            const offer = await peerConnection.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: false
            });
            await peerConnection.setLocalDescription(offer);
            await sendOffer(userId, offer);
            console.log('‚úÖ Offer sent to:', participant.name);
        }
        
        return peerConnection;
        
    } catch (error) {
        console.error('‚ùå Error creating peer connection:', error);
        throw error;
    }
}

    
        
// ===== HANDLE OFFER =====
async function handleOffer(fromUserId, offer) {
    try {
        console.log('üì® Handling offer from user:', fromUserId);
        
        // ‚úÖ Check if we're already trying to connect to this user
        if (peerConnections.has(fromUserId)) {
            const existingPc = peerConnections.get(fromUserId);
            
            // If we're in a negotiation state, let the lower UID win
            if (existingPc.signalingState !== 'stable') {
                console.log('‚ö†Ô∏è Simultaneous connection attempt detected');
                
                // Compare UIDs - lower UID's offer wins
                if (currentUser.uid < fromUserId) {
                    console.log('   ‚Üí My UID is lower, ignoring their offer (I already sent mine)');
                    return;
                } else {
                    console.log('   ‚Üí Their UID is lower, accepting their offer and closing mine');
                    existingPc.close();
                    peerConnections.delete(fromUserId);
                    
                    const oldAudio = document.getElementById(`audio_${fromUserId}`);
                    if (oldAudio) {
                        oldAudio.pause();
                        oldAudio.srcObject = null;
                        oldAudio.remove();
                    }
                }
            }
        }
        
        // Ensure we have a local audio stream
        if (!localAudioStream || localAudioStream.getTracks().length === 0) {
            console.error('‚ùå No local audio stream! Re-requesting...');
            try {
                localAudioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                localAudioStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMicMuted;
                });
                console.log('‚úÖ Re-acquired microphone for handling offer');
            } catch (error) {
                console.error('‚ùå Failed to re-acquire microphone:', error);
                throw error;
            }
        }
        
        // Close any existing connection first
        let peerConnection = peerConnections.get(fromUserId);
        if (peerConnection) {
            console.log('‚ö†Ô∏è Closing existing connection before handling offer');
            peerConnection.close();
            peerConnections.delete(fromUserId);
            
            const oldAudio = document.getElementById(`audio_${fromUserId}`);
            if (oldAudio) {
                oldAudio.pause();
                oldAudio.srcObject = null;
                oldAudio.remove();
            }
        }
        
        if (pendingIceCandidates.has(fromUserId)) {
            console.log('üóëÔ∏è Clearing old queued ICE candidates');
            pendingIceCandidates.delete(fromUserId);
        }
        
        // Get participant info
        const classId = myClass ? myClass.id : liveSessionId;
        const participantDoc = await db.collection('classes')
            .doc(classId)
            .collection('sessionParticipants')
            .doc(fromUserId)
            .get();
        
        if (!participantDoc.exists) {
            console.error('‚ùå Participant not found:', fromUserId);
            return;
        }
        
        const participant = participantDoc.data();
        console.log('üë§ Creating connection for:', participant.name);
        
        // Create new peer connection
        peerConnection = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10
        });
        
        // ‚úÖ CAPTURE CURRENT MIC STATE BEFORE ADDING TRACKS
        const currentMicState = isMicMuted;
        console.log('üì∏ Captured mic state for answer:', currentMicState ? 'MUTED' : 'UNMUTED');
        
        // Add local audio tracks
        console.log('üé§ Adding local audio tracks (answering)');
        localAudioStream.getTracks().forEach(track => {
            // ‚úÖ Set to ACTUAL current state
            track.enabled = !currentMicState;
            console.log('   ‚úÖ Track added:', track.kind, 'enabled:', track.enabled);
            peerConnection.addTrack(track, localAudioStream);
        });
        
        // Handle remote audio
        peerConnection.ontrack = (event) => {
            console.log('üì• Received track from:', participant.name);
            console.log('   Track kind:', event.track.kind);
            console.log('   Track enabled:', event.track.enabled);
            console.log('   Track readyState:', event.track.readyState);
            
            if (event.streams.length === 0) {
                console.error('‚ùå No streams!');
                return;
            }
            
            const remoteStream = event.streams[0];
            console.log('   Stream audio tracks:', remoteStream.getAudioTracks().length);
            remoteStreams.set(fromUserId, remoteStream);
            
            let audioElement = document.getElementById(`audio_${fromUserId}`);
            if (audioElement) {
                console.log('üóëÔ∏è Removing old audio element');
                audioElement.pause();
                audioElement.srcObject = null;
                audioElement.remove();
            }
            
            setTimeout(() => {
                audioElement = document.createElement('audio');
                audioElement.id = `audio_${fromUserId}`;
                audioElement.autoplay = true;
                audioElement.playsInline = true;
                audioElement.volume = 1.0;
                audioElement.srcObject = remoteStream;
                
                audioElement.onloadedmetadata = () => {
                    console.log('‚úÖ Audio metadata loaded for:', participant.name);
                };
                
                audioElement.onplay = () => {
                    console.log('‚úÖ Audio started playing for:', participant.name);
                };
                
                audioElement.onerror = (e) => {
                    console.error('‚ùå Audio element error:', e);
                };
                
                let container = document.getElementById('remote-audio-container');
                if (!container) {
                    console.warn('‚ö†Ô∏è Container not found, creating it');
                    container = document.createElement('div');
                    container.id = 'remote-audio-container';
                    container.style.display = 'none';
                    document.body.appendChild(container);
                }
                container.appendChild(audioElement);
                
                const playPromise = audioElement.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => console.log('‚úÖ Audio playing from:', participant.name))
                        .catch(err => {
                            console.error('‚ùå Playback error:', err);
                            if (err.name === 'NotAllowedError') {
                                alert(`Click OK to enable audio from ${participant.name}`);
                                audioElement.play();
                            }
                        });
                }
            }, 100);
        };
        
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('üßä Sending ICE candidate');
                sendIceCandidate(fromUserId, event.candidate);
            }
        };
        
        peerConnection.onconnectionstatechange = () => {
            console.log(`Connection state with ${participant.name}:`, peerConnection.connectionState);
            
            if (peerConnection.connectionState === 'connected') {
                console.log('‚úÖ Peer connection established with:', participant.name);
                
                // ‚úÖ START HEALTH MONITORING
                startConnectionHealthCheck(fromUserId, peerConnection, participant);
                
            } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                console.warn(`‚ö†Ô∏è Connection ${peerConnection.connectionState} with ${participant.name}`);
                
                // Stop health check
                if (connectionHealthChecks.has(fromUserId)) {
                    clearInterval(connectionHealthChecks.get(fromUserId));
                    connectionHealthChecks.delete(fromUserId);
                }
            }
        };
        
        peerConnection.oniceconnectionstatechange = () => {
            console.log(`ICE connection state with ${participant.name}:`, peerConnection.iceConnectionState);
            if (peerConnection.iceConnectionState === 'failed') {
                peerConnection.restartIce();
            }
        };
        
        peerConnections.set(fromUserId, peerConnection);
        
        // Set remote description (the offer)
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        console.log('‚úÖ Remote description set');
        
        // Create and send answer
        const answer = await peerConnection.createAnswer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: false
        });
        await peerConnection.setLocalDescription(answer);
        
        await sendAnswer(fromUserId, answer);
        console.log('‚úÖ Answer sent to:', participant.name);
        
        // Process any queued ICE candidates
        if (pendingIceCandidates.has(fromUserId)) {
            const queued = pendingIceCandidates.get(fromUserId);
            console.log(`üìã Processing ${queued.length} queued ICE candidates after offer`);
            
            for (const candidate of queued) {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log('‚úÖ Queued ICE candidate added');
                } catch (err) {
                    console.error('‚ùå Error adding queued candidate:', err);
                }
            }
            
            pendingIceCandidates.delete(fromUserId);
        }
        
    } catch (error) {
        console.error('‚ùå Error handling offer:', error);
    }
}
        
// ===== HANDLE ANSWER =====
async function handleAnswer(fromUserId, answer) {
    try {
        console.log('üì® Handling answer from user:', fromUserId);
        
        const peerConnection = peerConnections.get(fromUserId);
        
        if (!peerConnection) {
            console.warn('‚ö†Ô∏è No peer connection found for:', fromUserId, '- ignoring answer');
            return;
        }
        
        const currentState = peerConnection.signalingState;
        console.log('   Current signaling state:', currentState);
        
        // ‚úÖ Only process answer if we're waiting for one
        if (currentState === 'have-local-offer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            console.log('‚úÖ Answer processed from:', fromUserId);
            
            // ‚úÖ Process any queued ICE candidates now that remote description is set
            if (pendingIceCandidates.has(fromUserId)) {
                const queued = pendingIceCandidates.get(fromUserId);
                console.log(`üìã Processing ${queued.length} queued ICE candidates after answer`);
                
                for (const candidate of queued) {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log('‚úÖ Queued ICE candidate added');
                    } catch (err) {
                        console.error('‚ùå Error adding queued candidate:', err);
                    }
                }
                
                pendingIceCandidates.delete(fromUserId);
            }
        } else if (currentState === 'stable') {
            console.log('‚ö†Ô∏è Already in stable state - ignoring duplicate/stale answer');
        } else if (currentState === 'have-remote-offer') {
            console.warn('‚ö†Ô∏è Wrong role - we should be answering, not receiving answer. Ignoring.');
        } else {
            console.warn('‚ö†Ô∏è Unexpected signaling state:', currentState, '- ignoring answer');
        }
        
    } catch (error) {
        // ‚úÖ Catch and log without crashing
        console.error('‚ùå Error handling answer (non-fatal):', error.message);
    }
}
        
async function getParticipantData(userId) {
    const classId = myClass ? myClass.id : liveSessionId;
    const participantDoc = await db.collection('classes')
        .doc(classId)
        .collection('sessionParticipants')
        .doc(userId)
        .get();
    
    if (participantDoc.exists) {
        return participantDoc.data();
    }
    return { userId, name: 'Unknown', email: '' };
}


// ===== CLEANUP OLD SIGNALING MESSAGES =====
async function cleanupOldSignalingMessages(userId) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üóëÔ∏è Cleaning up ALL signaling messages for user:', userId);
    
    try {
        // ‚úÖ Delete ALL signaling messages in both directions
        const deletions = [];
        
        // Offers
        const offersFrom = await db.collection('classes').doc(classId).collection('offers').where('from', '==', userId).get();
        const offersTo = await db.collection('classes').doc(classId).collection('offers').where('to', '==', userId).get();
        offersFrom.forEach(doc => deletions.push(doc.ref.delete()));
        offersTo.forEach(doc => deletions.push(doc.ref.delete()));
        
        // Answers
        const answersFrom = await db.collection('classes').doc(classId).collection('answers').where('from', '==', userId).get();
        const answersTo = await db.collection('classes').doc(classId).collection('answers').where('to', '==', userId).get();
        answersFrom.forEach(doc => deletions.push(doc.ref.delete()));
        answersTo.forEach(doc => deletions.push(doc.ref.delete()));
        
        // ICE Candidates
        const candidatesFrom = await db.collection('classes').doc(classId).collection('iceCandidates').where('from', '==', userId).get();
        const candidatesTo = await db.collection('classes').doc(classId).collection('iceCandidates').where('to', '==', userId).get();
        candidatesFrom.forEach(doc => deletions.push(doc.ref.delete()));
        candidatesTo.forEach(doc => deletions.push(doc.ref.delete()));
        
        // Wait for all deletions to complete
        await Promise.all(deletions);
        
        console.log(`‚úÖ Deleted ${deletions.length} old signaling messages for ${userId}`);
        
    } catch (error) {
        console.error('Error cleaning up signaling:', error);
    }
}

        
// ===== WEBRTC SIGNALING =====
function listenForSignaling() {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üëÇ Setting up signaling listeners for class:', classId);
    
    // Listen for offers
    db.collection('classes')
        .doc(classId)
        .collection('offers')
        .where('to', '==', currentUser.uid)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    
                    // ‚úÖ Delete IMMEDIATELY before processing
                    const docRef = change.doc.ref;
                    docRef.delete().catch(e => console.error('Error deleting offer:', e));
                    
                    // ‚úÖ Ignore if we're cleaning up
                    if (isCleaningUp) {
                        console.log('‚è∏Ô∏è Ignoring offer during cleanup');
                        return;
                    }
                    
                    console.log('üì® Received offer from:', data.from);
                    await handleOffer(data.from, data.offer);
                }
            });
        });
    
    // Listen for answers
    db.collection('classes')
        .doc(classId)
        .collection('answers')
        .where('to', '==', currentUser.uid)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    const fromUserId = data.from;
                    
                    // ‚úÖ DELETE IMMEDIATELY FIRST
                    const docRef = change.doc.ref;
                    docRef.delete().catch(e => console.error('Error deleting answer:', e));
                    
                    // ‚úÖ Ignore if we're cleaning up
                    if (isCleaningUp) {
                        console.log('‚è∏Ô∏è Ignoring answer during cleanup');
                        return;
                    }
                    
                    // ‚úÖ CHECK STATE BEFORE CALLING handleAnswer
                    const peerConnection = peerConnections.get(fromUserId);
                    if (!peerConnection) {
                        console.warn('‚ö†Ô∏è No peer connection for answer from:', fromUserId);
                        return;
                    }
                    
                    if (peerConnection.signalingState !== 'have-local-offer') {
                        console.log('‚è≠Ô∏è Ignoring answer - wrong state:', peerConnection.signalingState);
                        return;
                    }
                    
                    console.log('üì® Processing answer from:', fromUserId);
                    await handleAnswer(fromUserId, data.answer);
                }
            });
        });
    
    // Listen for ICE candidates
    db.collection('classes')
        .doc(classId)
        .collection('iceCandidates')
        .where('to', '==', currentUser.uid)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    
                    // ‚úÖ Delete immediately
                    const docRef = change.doc.ref;
                    docRef.delete().catch(e => console.error('Error deleting candidate:', e));
                    
                    // ‚úÖ Ignore if we're cleaning up
                    if (isCleaningUp) {
                        console.log('‚è∏Ô∏è Ignoring ICE candidate during cleanup');
                        return;
                    }
                    
                    console.log('üì® Received ICE candidate from:', data.from);
                    await handleIceCandidate(data.from, data.candidate);
                }
            });
        });
}
        
// ===== SEND OFFER =====
async function sendOffer(toUserId, offer) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üì§ Sending offer to:', toUserId);
    
    await db.collection('classes')
        .doc(classId)
        .collection('offers')
        .add({
            from: currentUser.uid,
            to: toUserId,
            offer: {
                type: offer.type,
                sdp: offer.sdp
            },
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
}


// ===== SEND ANSWER =====
async function sendAnswer(toUserId, answer) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    console.log('üì§ Sending answer to:', toUserId);
    
    await db.collection('classes')
        .doc(classId)
        .collection('answers')
        .add({
            from: currentUser.uid,
            to: toUserId,
            answer: {
                type: answer.type,
                sdp: answer.sdp
            },
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
}
        

// ===== SEND ICE CANDIDATE =====
async function sendIceCandidate(toUserId, candidate) {
    const classId = myClass ? myClass.id : liveSessionId;
    
    await db.collection('classes')
        .doc(classId)
        .collection('iceCandidates')
        .add({
            from: currentUser.uid,
            to: toUserId,
            candidate: candidate.toJSON(),
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
}


// ===== HANDLE ICE CANDIDATE =====
async function handleIceCandidate(fromUserId, candidate) {
    try {
        const peerConnection = peerConnections.get(fromUserId);
        
        if (!peerConnection) {
            console.warn('‚ö†Ô∏è No peer connection found for:', fromUserId, '- ignoring ICE candidate');
            return;
        }
        
        // √¢≈ì‚Ä¶ Check if remote description is set
        if (peerConnection.remoteDescription && peerConnection.remoteDescription.type) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            console.log('‚úÖ ICE candidate added from:', fromUserId);
            
            // √¢≈ì‚Ä¶ Process any queued candidates
            if (pendingIceCandidates.has(fromUserId)) {
                const queued = pendingIceCandidates.get(fromUserId);
                console.log(`üìã Processing ${queued.length} queued ICE candidates`);
                
                for (const queuedCandidate of queued) {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(queuedCandidate));
                        console.log('‚úÖ Queued ICE candidate added');
                    } catch (err) {
                        console.error('‚ùå Error adding queued candidate:', err);
                    }
                }
                
                pendingIceCandidates.delete(fromUserId);
            }
        } else {
            // √¢≈ì‚Ä¶ Queue the candidate for later
            console.log('üì• Queueing ICE candidate (remote description not ready)');
            if (!pendingIceCandidates.has(fromUserId)) {
                pendingIceCandidates.set(fromUserId, []);
            }
            pendingIceCandidates.get(fromUserId).push(candidate);
        }
    } catch (error) {
        console.error('‚ùå Error handling ICE candidate:', error);
    }
}
// ===== TOGGLE MICROPHONE WITH SPEAKER LIMIT =====
async function toggleMicrophone() {
    if (!localAudioStream) {
        console.error('‚ùå No local audio stream to toggle!');
        return;
    }
    
    const audioTrack = localAudioStream.getAudioTracks()[0];
    if (!audioTrack) {
        console.error('‚ùå No audio track found!');
        return;
    }
    
    // Check if coach has muted this student
    if (coachMutedMe && isMicMuted) {
        alert('üîá Your coach has muted you. You cannot unmute yourself until the coach allows it.');
        return;
    }
    
    const classId = myClass ? myClass.id : liveSessionId;
    
    // If trying to unmute, check speaker limit
    if (isMicMuted && !isCoach) {
        // Count current active speakers (excluding self)
        const participantsSnapshot = await db.collection('classes')
            .doc(classId)
            .collection('sessionParticipants')
            .get();
        
        let activeCount = 0;
        participantsSnapshot.forEach(doc => {
            const data = doc.data();
            if (!data.micMuted && data.userId !== currentUser.uid) {
                activeCount++;
            }
        });
        
        if (activeCount >= MAX_ACTIVE_SPEAKERS) {
            alert(`‚ö†Ô∏è Maximum ${MAX_ACTIVE_SPEAKERS} speakers allowed at once. Please wait for someone to mute before unmuting.`);
            return;
        }
    }
    
    // Toggle the track
    audioTrack.enabled = !audioTrack.enabled;
    isMicMuted = !audioTrack.enabled;
    
    console.log('üé§ Microphone', isMicMuted ? 'MUTED' : 'UNMUTED', '- enabled:', audioTrack.enabled);
    
    // ‚úÖ UPDATE ALL PEER CONNECTION SENDERS
    peerConnections.forEach((pc, userId) => {
        const senders = pc.getSenders();
        senders.forEach(sender => {
            if (sender.track && sender.track.kind === 'audio') {
                sender.track.enabled = audioTrack.enabled;
                console.log(`   Updated audio sender for ${userId}: enabled=${audioTrack.enabled}`);
            }
        });
    });
    
    // Update activeSpeakers set
    if (isMicMuted) {
        activeSpeakers.delete(currentUser.uid);
    } else {
        activeSpeakers.add(currentUser.uid);
    }
    
    // Update button based on user type
    const btnId = isCoach ? 'coach-toggle-mic-btn' : 'student-toggle-mic-btn';
    const btn = document.getElementById(btnId);
    
    if (btn) {
        if (isMicMuted) {
            btn.textContent = 'üîá Unmute';
            btn.style.background = '#dc3545';
        } else {
            btn.textContent = 'üé§ Mute';
            btn.style.background = '#28a745';
        }
    }
    
    // Update in Firestore
    if (classId) {
        try {
            await db.collection('classes')
                .doc(classId)
                .collection('sessionParticipants')
                .doc(currentUser.uid)
                .update({ 
                    micMuted: isMicMuted,
                    lastMicUpdate: firebase.firestore.FieldValue.serverTimestamp()
                });
        } catch (error) {
            console.error('Error updating mic status in Firestore:', error);
        }
    }
}

        
  // ===== MUTE PARTICIPANT (COACH ONLY) =====
async function muteParticipant(userId, participantName) {
    if (!isCoach) {
        alert('Only coaches can mute participants');
        return;
    }
    
    if (!confirm(`MUTE ${participantName}?\n\nNote: Only the student can unmute themselves.`)) {
        return;
    }
    
    try {
        const classId = myClass.id;
        
        // Update in Firestore - force mute
        await db.collection('classes')
            .doc(classId)
            .collection('sessionParticipants')
            .doc(userId)
            .update({ 
                micMuted: true,
                coachMuted: true // Track that coach did this
            });
        
        console.log(`‚úÖ Muted ${participantName}`);
        
        // Update local map
        const participant = sessionParticipants.get(userId);
        if (participant) {
            participant.micMuted = true;
            participant.coachMuted = true;
            sessionParticipants.set(userId, participant);
        }
        
        // Update UI
        updateParticipantsList();
        
    } catch (error) {
        console.error('Error muting participant:', error);
        alert('Failed to mute participant: ' + error.message);
    }
}
        
// ===== UPDATE PARTICIPANTS LIST =====
function updateParticipantsList() {
    const containerId = isCoach ? 'coach-session-participants-list' : 'student-session-participants-list';
    const container = document.getElementById(containerId);
    
    if (!container) {
        console.error('Participants container not found:', containerId);
        return;
    }
    
    if (sessionParticipants.size === 0) {
        container.innerHTML = '<p style="color: #666;">No participants yet</p>';
        return;
    }
    
    // Count active speakers
    let activeSpeakerCount = 0;
    sessionParticipants.forEach(p => {
        if (!p.micMuted) activeSpeakerCount++;
    });
    
    // Update participant count for coach
    if (isCoach) {
        const countEl = document.getElementById('participant-count');
        if (countEl) countEl.textContent = sessionParticipants.size;
    }
    
    // Add speaker limit warning
    const speakerWarning = activeSpeakerCount >= MAX_ACTIVE_SPEAKERS 
        ? `<div style="background: #fff3cd; color: #856404; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-weight: bold;">
            ‚ö†Ô∏è Maximum speakers reached (${activeSpeakerCount}/${MAX_ACTIVE_SPEAKERS})
           </div>`
        : `<div style="background: #d4edda; color: #155724; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
            üé§ Active speakers: ${activeSpeakerCount}/${MAX_ACTIVE_SPEAKERS}
           </div>`;
    
    container.innerHTML = speakerWarning + Array.from(sessionParticipants.values())
        .map(participant => {
            const avatarHtml = participant.photoURL 
                ? `<div class="coach-avatar" style="width: 40px; height: 40px; background-image: url('${participant.photoURL}'); background-size: cover;"></div>`
                : `<div class="coach-avatar" style="width: 40px; height: 40px;">${(participant.name || 'U').charAt(0).toUpperCase()}</div>`;
            
            const micStatus = participant.micMuted ? 'üîá' : 'üé§';
            const isCurrentUser = participant.userId === currentUser.uid;
            
            // Coach can ONLY mute (not unmute) other participants
            const coachControls = isCoach && !isCurrentUser ? `
                <button 
                    onclick="muteParticipant('${participant.userId}', '${participant.name.replace(/'/g, "\\'")}')"
                    style="
                        background: #dc3545;
                        color: white;
                        border: none;
                        padding: 8px 15px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 0.9rem;
                        font-weight: bold;
                        transition: all 0.3s;
                    "
                    onmouseover="this.style.opacity='0.8'"
                    onmouseout="this.style.opacity='1'"
                >
                    üîá Mute
                </button>
            ` : '';
            
            // Show if coach has muted them
            const coachMutedLabel = participant.coachMuted ? 
                '<span style="color: #dc3545; font-size: 0.8rem; font-weight: bold;">(Coach Muted)</span>' : '';
            
            return `
                <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: white; border-radius: 8px; margin-bottom: 10px;">
                    ${avatarHtml}
                    <div style="flex: 1;">
                        <div style="font-weight: bold; color: #0d3b66;">
                            ${participant.name}${isCurrentUser ? ' (You)' : ''}
                            ${coachMutedLabel}
                        </div>
                        <div style="font-size: 0.9rem; color: #666;">${participant.email}</div>
                    </div>
                    <div style="font-size: 1.5rem;">${micStatus}</div>
                    ${coachControls}
                </div>
            `;
        }).join('');
}

    

// ===== CLOSE PEER CONNECTION =====
function closePeerConnection(userId) {
    const peerConnection = peerConnections.get(userId);
    if (peerConnection) {
        peerConnection.close();
        peerConnections.delete(userId);
    }
    
    // √¢≈ì‚Ä¶ Clear queued ICE candidates
    if (pendingIceCandidates.has(userId)) {
        console.log('üóëÔ∏è Clearing queued ICE candidates for:', userId);
        pendingIceCandidates.delete(userId);
    }
    
    const audioElement = document.getElementById(`audio_${userId}`);
    if (audioElement) {
        audioElement.pause();
        audioElement.srcObject = null;
        audioElement.remove();
    }
    
    remoteStreams.delete(userId);
}

// ===== END LIVE SESSION =====
async function endLiveSession() {
    const isCoachUser = isCoach;
    const confirmMessage = isCoachUser 
        ? 'Are you sure you want to end the live session for everyone?' 
        : 'Are you sure you want to leave the live session?';
    
    if (!confirm(confirmMessage)) {
        return;
    }
    
    try {
        console.log('üõë Ending live session...');
        
        // Stop all health checks
        connectionHealthChecks.forEach(intervalId => clearInterval(intervalId));
        connectionHealthChecks.clear();
        
        // Stop and remove ALL audio elements first
        document.querySelectorAll('audio').forEach(audio => {
            console.log('üóëÔ∏è Removing audio element:', audio.id);
            audio.pause();
            audio.srcObject = null;
            audio.remove();
        });
        
        // Stop local audio tracks
        if (localAudioStream) {
            console.log('üõë Stopping local audio stream');
            localAudioStream.getTracks().forEach(track => {
                console.log('   Stopping track:', track.kind, track.id);
                track.stop();
            });
            localAudioStream = null;
        }
        
        // Close ALL peer connections
        console.log('üõë Closing peer connections:', peerConnections.size);
        peerConnections.forEach((pc, userId) => {
            console.log('   Closing connection with:', userId);
            try {
                pc.close();
            } catch (e) {
                console.error('   Error closing connection:', e);
            }
        });
        peerConnections.clear();
        
        // Clear all queued ICE candidates
        pendingIceCandidates.clear();
        console.log('üóëÔ∏è Cleared all queued ICE candidates');
        
        // Clear remote streams
        remoteStreams.clear();
        
        // Clear active speakers
        activeSpeakers.clear();
        
        // Unsubscribe from session listeners
        if (liveSessionListener) {
            console.log('üõë Unsubscribing from session listener');
            try {
                liveSessionListener();
            } catch (e) {
                console.error('Error unsubscribing:', e);
            }
            liveSessionListener = null;
        }
        
        // Remove from participants in Firestore
        const classId = myClass ? myClass.id : liveSessionId;
        if (classId && currentUser) {
            console.log('üóëÔ∏è Removing from session participants');
            await db.collection('classes')
                .doc(classId)
                .collection('sessionParticipants')
                .doc(currentUser.uid)
                .delete();
        }
        
        // If coach, end session for everyone
        if (isCoachUser && myClass) {
            console.log('üõë Coach ending session for everyone');
            
            await db.collection('classes').doc(myClass.id).update({
                liveSessionActive: false,
                liveSessionId: null
            });
            
            // Clear all participants
            const participantsSnapshot = await db.collection('classes')
                .doc(myClass.id)
                .collection('sessionParticipants')
                .get();
            
            const batch = db.batch();
            participantsSnapshot.forEach(doc => {
                batch.delete(doc.ref);
            });
            await batch.commit();
            
            // Clear signaling data
            console.log('üóëÔ∏è Clearing signaling data');
            const [offersSnap, answersSnap, candidatesSnap] = await Promise.all([
                db.collection('classes').doc(myClass.id).collection('offers').get(),
                db.collection('classes').doc(myClass.id).collection('answers').get(),
                db.collection('classes').doc(myClass.id).collection('iceCandidates').get()
            ]);
            
            const signalingBatch = db.batch();
            offersSnap.forEach(doc => signalingBatch.delete(doc.ref));
            answersSnap.forEach(doc => signalingBatch.delete(doc.ref));
            candidatesSnap.forEach(doc => signalingBatch.delete(doc.ref));
            await signalingBatch.commit();
        }
        
        // Clear session participants map
        sessionParticipants.clear();
        
        // Reset state variables
        liveSessionActive = false;
        liveSessionId = null;
        isMicMuted = false;
        
        // Reset UI based on user type
        if (isCoachUser) {
            const startBtn = document.getElementById('start-session-btn');
            const liveSessionContainer = document.getElementById('coach-live-session-active');
            
            if (liveSessionContainer) liveSessionContainer.style.display = 'none';
            if (startBtn) {
                startBtn.style.display = 'block';
                startBtn.textContent = 'üé• Start Live Session';
                startBtn.style.background = '#28a745';
            }
            
            // Clear participants list
            const participantsList = document.getElementById('coach-session-participants-list');
            if (participantsList) participantsList.innerHTML = '<p style="color: #666;">No participants</p>';
            
        } else {
            // Student: Reload view to show correct UI
            await loadStudentClassView();
        }
        
        const message = isCoachUser ? '‚úÖ Live session ended' : '‚úÖ Left live session';
        alert(message);
        
        console.log('‚úÖ Session cleanup complete');
        
    } catch (error) {
        console.error('‚ùå Error ending session:', error);
        alert('Error ending session: ' + error.message);
    }
}

// ===== CHECK FOR ACTIVE SESSION (FOR STUDENTS) =====
async function checkForActiveSession() {
    if (!currentUser) return;
    
    try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        
        if (!userData || !userData.classId || userData.userType !== 'student') return;
        
        const classDoc = await db.collection('classes').doc(userData.classId).get();
        const classData = classDoc.data();
        
        if (classData && classData.liveSessionActive) {
            // Show join button
            const studentClassInfo = document.getElementById('student-class-info');
            
            const joinBtnHtml = `
                <div style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); padding: 20px; border-radius: 10px; text-align: center; margin-top: 20px;">
                    <h3 style="color: white; margin-bottom: 15px;">üé• Live Session Active!</h3>
                    <button id="join-session-btn" class="practice-btn" onclick="joinLiveSession()" style="background: white; color: #28a745; font-size: 1.2rem;">
                        Join Live Session
                    </button>
                </div>
            `;
            
            // Check if button doesn't already exist
            if (!document.getElementById('join-session-btn')) {
                studentClassInfo.insertAdjacentHTML('beforeend', joinBtnHtml);
            }
        }
    } catch (error) {
        console.error('Error checking for active session:', error);
    }
}  

   // ===== BOOK COACH (STUDENT) =====
async function bookCoach(coachId, coachName) {
    if (!currentUser) {
        alert('Please sign in to book a coach');
        return;
    }
    
    if (!confirm(`Book ${coachName} as your coach?\n\nThis will add you to their class.`)) {
        return;
    }
    
    try {
        // Get coach's class
        const classQuery = await db.collection('classes')
            .where('coachId', '==', coachId)
            .limit(1)
            .get();
        
        if (classQuery.empty) {
            alert('‚ùå Coach class not found. Please try again later.');
            return;
        }
        
        const classDoc = classQuery.docs[0];
        const classId = classDoc.id;
        
        // Check if student already has a coach
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        
        if (userData.classId && userData.classId !== classId) {
            if (!confirm('You are already in another class. Switch to this coach?')) {
                return;
            }
            
            // Remove from old class count
            try {
                const oldClassDoc = await db.collection('classes').doc(userData.classId).get();
                if (oldClassDoc.exists) {
                    const oldCount = oldClassDoc.data().studentCount || 0;
                    await db.collection('classes').doc(userData.classId).update({
                        studentCount: Math.max(0, oldCount - 1)
                    });
                }
            } catch (error) {
                console.error('Error updating old class count:', error);
            }
        }
        
        // Update student with classId
        await db.collection('users').doc(currentUser.uid).update({
            classId: classId,
            coachId: coachId
        });
        
        // Update class student count
        const currentCount = classDoc.data().studentCount || 0;
        await db.collection('classes').doc(classId).update({
            studentCount: currentCount + 1
        });
        
        alert(`‚úÖ Successfully booked ${coachName}!\n\nYou can now access your class from the "MY CLASS" button.`);
        closeCoachDetailModal();
        
        // Show MY CLASS button
        const myClassBtn = document.getElementById('myClassBtn');
        if (myClassBtn) {
            myClassBtn.style.display = 'block';
        }
        
    } catch (error) {
        console.error('Error booking coach:', error);
        alert('Failed to book coach: ' + error.message);
    }
}

// ===== RECRUIT STUDENT (COACH) =====
async function recruitStudent(studentId, studentName) {
    if (!currentUser || !myClass) {
        alert('Please ensure you have a class set up first');
        return;
    }
    
    if (!confirm(`Recruit ${studentName} to your class?`)) {
        return;
    }
    
    try {
        // Check if student already has a coach
        const studentDoc = await db.collection('users').doc(studentId).get();
        const studentData = studentDoc.data();
        
        if (studentData.classId && studentData.classId !== myClass.id) {
            if (!confirm(`${studentName} is already in another class. Recruit anyway?`)) {
                return;
            }
            
            // Remove from old class count
            try {
                const oldClassDoc = await db.collection('classes').doc(studentData.classId).get();
                if (oldClassDoc.exists) {
                    const oldCount = oldClassDoc.data().studentCount || 0;
                    await db.collection('classes').doc(studentData.classId).update({
                        studentCount: Math.max(0, oldCount - 1)
                    });
                }
            } catch (error) {
                console.error('Error updating old class count:', error);
            }
        }
        
        // Add student to coach's class
        await db.collection('users').doc(studentId).update({
            classId: myClass.id,
            coachId: currentUser.uid
        });
        
        // Update class student count
        const currentCount = myClass.studentCount || 0;
        await db.collection('classes').doc(myClass.id).update({
            studentCount: currentCount + 1
        });
        
        // Update myClass object
        myClass.studentCount = currentCount + 1;
        
        alert(`‚úÖ Successfully recruited ${studentName} to your class!`);
        closeStudentDetailModal();
        
        // Reload class students
        await loadClassStudents();
        updateCoachClassStats();
        
    } catch (error) {
        console.error('Error recruiting student:', error);
        alert('Failed to recruit student: ' + error.message);
    }
}    


  // ===== ADMIN CONFIGURATION =====
const ADMIN_EMAIL = 'carlanviroberts@gmail.com'; // ‚ö†Ô∏è CHANGE THIS TO YOUR ADMIN EMAIL
let isAdmin = false;

// Check if current user is admin
async function checkAdminStatus() {
    if (!currentUser) {
        isAdmin = false;
        updateAdminUI();
        console.log('‚ùå No current user - admin status: false');
        return false;
    }
    
    try {
        console.log('üîç Checking admin status for:', currentUser.email);
        console.log('üîç Admin email configured as:', ADMIN_EMAIL);
        
        // Check email directly first
        if (currentUser.email === ADMIN_EMAIL) {
            isAdmin = true;
            console.log('‚úÖ ADMIN DETECTED via email match!');
            updateAdminUI();
            return true;
        }
        
        // Also check Firestore user document
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        
        if (userDoc.exists) {
            const userData = userDoc.data();
            isAdmin = (userData?.email === ADMIN_EMAIL);
            console.log('üìÑ Firestore check - Admin status:', isAdmin);
        } else {
            console.log('‚ö†Ô∏è User document not found in Firestore');
        }
        
        updateAdminUI();
        return isAdmin;
        
    } catch (error) {
        console.error('‚ùå Error checking admin status:', error);
        isAdmin = false;
        updateAdminUI();
        return false;
    }
}

function updateAdminUI() {
    console.log('üîÑ Updating admin UI. isAdmin:', isAdmin);
    
    // Show/hide admin link in sidebar
    const adminLink = document.getElementById('admin-nav-link');
    if (adminLink) {
        adminLink.style.display = isAdmin ? 'block' : 'none';
        console.log('‚úÖ Admin link display set to:', isAdmin ? 'block' : 'none');
    } else {
        console.log('‚ö†Ô∏è Admin link element not found in DOM');
    }
}

// ===== ADMIN PANEL WITH SECTIONS =====

let currentAdminSection = 'tournaments'; // Default section
let currentUserSubSection = 'students'; // Default user sub-section

async function loadAdminPanel() {
    if (!isAdmin) {
        document.getElementById('admin-container').innerHTML = `
            <div class="feedback error" style="text-align: center; padding: 40px;">
                ‚ùå <strong>Access Denied</strong><br><br>
                Admin privileges required.<br>
                Current user: ${currentUser ? currentUser.email : 'Not signed in'}
            </div>
        `;
        return;
    }
    
    const container = document.getElementById('admin-container');
    container.innerHTML = `
        <div class="admin-panel">
            <!-- Admin Navigation -->
            <div style="display: flex; gap: 15px; margin-bottom: 30px; justify-content: center;">
                <button class="practice-btn" id="admin-tournaments-btn" onclick="switchAdminSection('tournaments')" style="padding: 12px 30px; font-size: 1.1rem;">
                    üèÜ Tournaments
                </button>
                <button class="practice-btn" id="admin-users-btn" onclick="switchAdminSection('users')" style="padding: 12px 30px; font-size: 1.1rem;">
                    üë• Users
                </button>
            </div>
            
            <!-- Content Container -->
            <div id="admin-content-container">
                <div class="loading">Loading...</div>
            </div>
        </div>
    `;
    
    // Load default section
    switchAdminSection('tournaments');
}

async function switchAdminSection(section) {
    currentAdminSection = section;
    
    // Update button styles
    const tournamentsBtn = document.getElementById('admin-tournaments-btn');
    const usersBtn = document.getElementById('admin-users-btn');
    
    if (tournamentsBtn && usersBtn) {
        tournamentsBtn.style.background = section === 'tournaments' ? 'linear-gradient(135deg, #667eea, #764ba2)' : '#6c757d';
        usersBtn.style.background = section === 'users' ? 'linear-gradient(135deg, #667eea, #764ba2)' : '#6c757d';
    }
    
    const contentContainer = document.getElementById('admin-content-container');
    
    if (section === 'tournaments') {
        await loadAdminTournaments(contentContainer);
    } else if (section === 'users') {
        await loadAdminUsersSection(contentContainer);
    }
}

// ===== TOURNAMENTS SECTION =====

async function loadAdminTournaments(container) {
    container.innerHTML = '<div class="loading">Loading tournaments...</div>';
    
    try {
        const tournamentsSnapshot = await db.collection('tournaments')
            .orderBy('createdAt', 'desc')
            .get();
        
        const tournaments = [];
        tournamentsSnapshot.forEach(doc => {
            tournaments.push({ id: doc.id, ...doc.data() });
        });
        
        container.innerHTML = `
            <div style="text-align: center; margin-bottom: 30px;">
                <button class="practice-btn" onclick="showCreateTournamentModal()" style="font-size: 1.2rem; padding: 15px 40px; background: linear-gradient(135deg, #667eea, #764ba2);">
                    ‚ûï Create New Tournament
                </button>
            </div>
            
            <h3 style="color: #0d3b66; margin-bottom: 20px;">üìã Manage Tournaments (${tournaments.length})</h3>
            
            ${tournaments.length === 0 ? `
                <div class="loading">
                    No tournaments created yet. Click "Create New Tournament" to get started.
                </div>
            ` : `
                <div class="coaches-table">
                    <table>
                        <thead>
                            <tr>
                                <th>üèÜ Tournament</th>
                                <th>üìÖ Date</th>
                                <th>üë• Participants</th>
                                <th>‚öôÔ∏è Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tournaments.map(tournament => `
                                <tr>
                                    <td>
                                        <div style="font-weight: bold; color: #0d3b66;">${tournament.name}</div>
                                        <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">
                                            Level: ${tournament.level} ‚Ä¢ Status: ${tournament.status}
                                        </div>
                                    </td>
                                    <td>
                                        <div>${tournament.startDate ? new Date(tournament.startDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : 'Not scheduled'}</div>
                                        <div style="font-size: 0.85rem; color: #666; margin-top: 3px;">
                                            ${tournament.startTime || 'Time TBD'}
                                        </div>
                                    </td>
                                    <td style="text-align: center;">
                                        <span style="background: #e3f2fd; padding: 5px 15px; border-radius: 15px; font-weight: bold; color: #0d3b66;">
                                            ${tournament.participants || 0}
                                        </span>
                                    </td>
                                    <td>
                                        <div style="display: flex; gap: 5px; justify-content: center;">
                                            <button class="practice-btn" onclick="viewTournament('${tournament.id}')" style="padding: 8px 15px; font-size: 0.85rem; background: #17a2b8;">
                                                üëÅÔ∏è View
                                            </button>
                                            <button class="practice-btn" onclick="editTournament('${tournament.id}')" style="padding: 8px 15px; font-size: 0.85rem; background: #ffc107; color: #0d3b66;">
                                                ‚úèÔ∏è Edit
                                            </button>
                                            <button class="practice-btn" onclick="deleteTournament('${tournament.id}')" style="padding: 8px 15px; font-size: 0.85rem; background: #dc3545;">
                                                üóëÔ∏è Delete
                                            </button>
                                        </div>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `}
        `;
        
    } catch (error) {
        console.error('Error loading tournaments:', error);
        container.innerHTML = `
            <div class="feedback error">
                ‚ùå Failed to load tournaments: ${error.message}
            </div>
        `;
    }
}



 async function switchUserSubSection(subSection) {
    currentUserSubSection = subSection;
    
    // Update button styles
    const studentsBtn = document.getElementById('admin-students-btn');
    const coachesBtn = document.getElementById('admin-coaches-btn');
    
    if (studentsBtn && coachesBtn) {
        studentsBtn.style.background = subSection === 'students' ? 'linear-gradient(135deg, #667eea, #764ba2)' : '#6c757d';
        coachesBtn.style.background = subSection === 'coaches' ? 'linear-gradient(135deg, #667eea, #764ba2)' : '#6c757d';
    }
    
    const listContainer = document.getElementById('admin-user-list-container');
    
    if (subSection === 'students') {
        await loadAdminStudentsList(listContainer);
    } else if (subSection === 'coaches') {
        await loadAdminCoachesList(listContainer);
    }
}

// ===== STUDENTS LIST =====

async function loadAdminStudentsList(container) {
    container.innerHTML = '<div class="loading">Loading students...</div>';
    
    try {
        const studentsSnapshot = await db.collection('users')
            .where('userType', '==', 'student')
            .orderBy('createdAt', 'desc')
            .get();
        
        const students = [];
        studentsSnapshot.forEach(doc => {
            students.push({ id: doc.id, ...doc.data() });
        });
        
        if (students.length === 0) {
            container.innerHTML = `
                <div class="loading">
                    No students found on the platform.
                </div>
            `;
            return;
        }
        
        container.innerHTML = `
            <h3 style="color: #0d3b66; margin-bottom: 20px;">üéì All Students (${students.length})</h3>
            
            <div class="coaches-table">
                <table>
                    <thead>
                        <tr>
                            <th>üë§ Student</th>
                            <th>üìß Email</th>
                            <th>üìÖ Joined</th>
                            <th>üîí Status</th>
                            <th>‚öôÔ∏è Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${students.map(student => `
                            <tr onclick="viewStudentDetailsAdmin('${student.id}')" style="cursor: pointer;">
                                <td>
                                    <div style="font-weight: bold; color: #0d3b66;">${student.name || student.firstName || 'N/A'} ${student.lastName || ''}</div>
                                    <div style="font-size: 0.85rem; color: #666;">ID: ${student.id.substring(0, 8)}...</div>
                                </td>
                                <td>${student.email || 'No email'}</td>
                                <td>${student.createdAt ? new Date(student.createdAt.toDate()).toLocaleDateString() : 'N/A'}</td>
                                <td style="text-align: center;">
                                    ${student.subscriptionLocked ? 
                                        '<span style="background: #ff6b6b; color: white; padding: 5px 10px; border-radius: 15px; font-size: 0.85rem;">üîí Locked</span>' : 
                                        '<span style="background: #51cf66; color: white; padding: 5px 10px; border-radius: 15px; font-size: 0.85rem;">‚úÖ Active</span>'
                                    }
                                </td>
                                <td onclick="event.stopPropagation();">
                                    <div style="display: flex; gap: 5px; justify-content: center;">
                                        ${student.subscriptionLocked ? 
                                            `<button class="practice-btn" onclick="unlockStudentAccount('${student.id}')" style="padding: 8px 15px; font-size: 0.85rem; background: #51cf66;">
                                                üîì Unlock
                                            </button>` :
                                            `<button class="practice-btn" onclick="lockStudentAccount('${student.id}')" style="padding: 8px 15px; font-size: 0.85rem; background: #ffc107; color: #0d3b66;">
                                                üîí Lock
                                            </button>`
                                        }
                                        <button class="practice-btn" onclick="deleteStudentAccount('${student.id}', '${(student.name || student.firstName || 'Student') + ' ' + (student.lastName || '')}')" style="padding: 8px 15px; font-size: 0.85rem; background: #dc3545;">
                                            üóëÔ∏è Delete
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        `;
        
    } catch (error) {
        console.error('Error loading students:', error);
        container.innerHTML = `
            <div class="feedback error">
                ‚ùå Failed to load students: ${error.message}
            </div>
        `;
    }
}

// ===== COACHES LIST =====

async function loadAdminCoachesList(container) {
    container.innerHTML = '<div class="loading">Loading coaches...</div>';
    
    try {
        const coachesSnapshot = await db.collection('users')
            .where('userType', '==', 'coach')
            .orderBy('createdAt', 'desc')
            .get();
        
        const coaches = [];
        coachesSnapshot.forEach(doc => {
            coaches.push({ id: doc.id, ...doc.data() });
        });
        
        if (coaches.length === 0) {
            container.innerHTML = `
                <div class="loading">
                    No coaches found on the platform.
                </div>
            `;
            return;
        }
        
        container.innerHTML = `
            <h3 style="color: #0d3b66; margin-bottom: 20px;">üë®‚Äçüè´ All Coaches (${coaches.length})</h3>
            
            <div class="coaches-table">
                <table>
                    <thead>
                        <tr>
                            <th>üë§ Coach</th>
                            <th>üìß Email</th>
                            <th>üë• Students</th>
                            <th>üìÖ Joined</th>
                            <th>üîí Status</th>
                            <th>‚öôÔ∏è Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${coaches.map(coach => `
                            <tr onclick="viewCoachDetailsAdmin('${coach.id}')" style="cursor: pointer;">
                                <td>
                                    <div style="font-weight: bold; color: #0d3b66;">${coach.name || coach.firstName || 'N/A'} ${coach.lastName || ''}</div>
                                    <div style="font-size: 0.85rem; color: #666;">ID: ${coach.id.substring(0, 8)}...</div>
                                </td>
                                <td>${coach.email || 'No email'}</td>
                                <td style="text-align: center;">
                                    <span style="background: #e3f2fd; padding: 5px 15px; border-radius: 15px; font-weight: bold; color: #0d3b66;">
                                        ${coach.studentCount || 0}
                                    </span>
                                </td>
                                <td>${coach.createdAt ? new Date(coach.createdAt.toDate()).toLocaleDateString() : 'N/A'}</td>
                                <td style="text-align: center;">
                                    ${coach.subscriptionLocked ? 
                                        '<span style="background: #ff6b6b; color: white; padding: 5px 10px; border-radius: 15px; font-size: 0.85rem;">üîí Locked</span>' : 
                                        '<span style="background: #51cf66; color: white; padding: 5px 10px; border-radius: 15px; font-size: 0.85rem;">‚úÖ Active</span>'
                                    }
                                </td>
                                <td onclick="event.stopPropagation();">
                                    <div style="display: flex; gap: 5px; justify-content: center;">
                                        ${coach.subscriptionLocked ? 
                                            `<button class="practice-btn" onclick="unlockCoachAccount('${coach.id}')" style="padding: 8px 15px; font-size: 0.85rem; background: #51cf66;">
                                                üîì Unlock
                                            </button>` :
                                            `<button class="practice-btn" onclick="lockCoachAccount('${coach.id}')" style="padding: 8px 15px; font-size: 0.85rem; background: #ffc107; color: #0d3b66;">
                                                üîí Lock
                                            </button>`
                                        }
                                        <button class="practice-btn" onclick="deleteCoachAccount('${coach.id}', '${(coach.name || coach.firstName || 'Coach') + ' ' + (coach.lastName || '')}')" style="padding: 8px 15px; font-size: 0.85rem; background: #dc3545;">
                                            üóëÔ∏è Delete
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        `;
        
    } catch (error) {
        console.error('Error loading coaches:', error);
        container.innerHTML = `
            <div class="feedback error">
                ‚ùå Failed to load coaches: ${error.message}
            </div>
        `;
    }
}
        
// ===== USERS SECTION =====

async function loadAdminUsersSection(container) {
    container.innerHTML = `
        <div>
            <!-- User Type Navigation -->
            <div style="display: flex; gap: 15px; margin-bottom: 30px; justify-content: center;">
                <button class="practice-btn" id="admin-students-btn" onclick="switchUserSubSection('students')" style="padding: 10px 25px;">
                    üéì Students
                </button>
                <button class="practice-btn" id="admin-coaches-btn" onclick="switchUserSubSection('coaches')" style="padding: 10px 25px;">
                    üë®‚Äçüè´ Coaches
                </button>
            </div>
            
            <!-- User List Container -->
            <div id="admin-user-list-container">
                <div class="loading">Loading users...</div>
            </div>
        </div>
    `;
    
    // Load default sub-section
    switchUserSubSection('students');
}

async function switchUserSubSection(subSection) {
    currentUserSubSection = subSection;
    
    // Update button styles
    const studentsBtn = document.getElementById('admin-students-btn');
    const coachesBtn = document.getElementById('admin-coaches-btn');
    
    if (studentsBtn && coachesBtn) {
        studentsBtn.style.background = subSection === 'students' ? 'linear-gradient(135deg, #667eea, #764ba2)' : '#6c757d';
        coachesBtn.style.background = subSection === 'coaches' ? 'linear-gradient(135deg, #667eea, #764ba2)' : '#6c757d';
    }
    
    const listContainer = document.getElementById('admin-user-list-container');
    
    if (subSection === 'students') {
        await loadAdminStudentsList(listContainer);
    } else if (subSection === 'coaches') {
        await loadAdminCoachesList(listContainer);
    }
}



// ===== STUDENT ADMIN ACTIONS =====

async function viewStudentDetailsAdmin(studentId) {
    try {
        const studentDoc = await db.collection('users').doc(studentId).get();
        
        if (!studentDoc.exists) {
            alert('‚ùå Student not found');
            return;
        }
        
        const student = studentDoc.data();
        
        // Get student's progress data
        const progressSnapshot = await db.collection('users').doc(studentId)
            .collection('progress')
            .orderBy('timestamp', 'desc')
            .limit(10)
            .get();
        
        const progressData = [];
        progressSnapshot.forEach(doc => {
            progressData.push(doc.data());
        });
        
        // Format subscription info
        const subscriptionExpiry = student.subscriptionExpiry?.toDate();
        const subscriptionType = student.subscriptionType || 'trial';
        const now = new Date();
        let subscriptionStatus = '';
        
        if (!subscriptionExpiry) {
            subscriptionStatus = 'üîí No Subscription';
        } else if (now > subscriptionExpiry) {
            subscriptionStatus = `üîí Expired on ${subscriptionExpiry.toLocaleDateString()}`;
        } else {
            const daysLeft = Math.ceil((subscriptionExpiry - now) / (1000 * 60 * 60 * 24));
            subscriptionStatus = `${subscriptionType === 'trial' ? 'üéÅ Trial' : '‚úÖ Active'} - Expires ${subscriptionExpiry.toLocaleDateString()} (${daysLeft} days left)`;
        }
        
        const modal = document.createElement('div');
        modal.className = 'auth-modal active';
        modal.style.display = 'block';
        
        modal.innerHTML = `
            <div class="auth-content" style="max-width: 700px;">
                <div class="auth-header" style="background: linear-gradient(135deg, #667eea, #764ba2);">
                    <h2 style="color: white;">üë§ Student Details</h2>
                    <button class="modal-close" onclick="this.closest('.auth-modal').remove()" style="color: white;">√ó</button>
                </div>
                <div class="auth-body">
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #0d3b66; margin-bottom: 15px;">üìã Basic Information</h3>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                            <p><strong>Name:</strong> ${student.name || student.firstName || 'N/A'} ${student.lastName || ''}</p>
                            <p><strong>Email:</strong> ${student.email || 'N/A'}</p>
                            <p><strong>User ID:</strong> ${studentId}</p>
                            <p><strong>Student ID:</strong> ${student.studentId || `WB-2025-${studentId.slice(-4).toUpperCase()}`}</p>
                            <p><strong>Account Created:</strong> ${student.createdAt ? new Date(student.createdAt.toDate()).toLocaleDateString() : 'N/A'}</p>
                            <p><strong>Account Status:</strong> ${student.subscriptionLocked ? 'üîí Locked' : '‚úÖ Active'}</p>
                            <p><strong>Subscription:</strong> ${subscriptionStatus}</p>
                            <p><strong>Coins:</strong> ü™ô ${student.coins || 0}</p>
                            <p><strong>Coach ID:</strong> ${student.coachId || 'No coach assigned'}</p>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #0d3b66; margin-bottom: 15px;">üìä Recent Activity</h3>
                        ${progressData.length === 0 ? 
                            '<p style="color: #666;">No practice sessions recorded yet.</p>' :
                            `<div style="background: #f8f9fa; padding: 15px; border-radius: 10px; max-height: 200px; overflow-y: auto;">
                                ${progressData.map(session => `
                                    <div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 5px;">
                                        <strong>${session.difficulty || 'Unknown'}</strong> - 
                                        Score: ${session.score || 0}/${session.totalWords || 0} 
                                        (${session.accuracy || 0}%)
                                        <br>
                                        <small style="color: #666;">${session.timestamp ? new Date(session.timestamp.toDate()).toLocaleString() : 'N/A'}</small>
                                    </div>
                                `).join('')}
                            </div>`
                        }
                    </div>
                    
                    <button class="auth-submit" onclick="this.closest('.auth-modal').remove()">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
    } catch (error) {
        console.error('Error viewing student details:', error);
        alert('‚ùå Failed to load student details: ' + error.message);
    }
}

async function unlockStudentAccount(studentId) {
    if (!confirm('Are you sure you want to unlock this student account?\n\nThis will:\n‚úÖ Remove the subscription lock\n‚úÖ Hide the subscription modal\n‚úÖ Grant full access to all features')) {
        return;
    }
    
    try {
        // Set subscription expiry to 30 days from now
        const newExpiry = new Date();
        newExpiry.setDate(newExpiry.getDate() + 30);
        
        await db.collection('users').doc(studentId).update({
            subscriptionLocked: false,
            subscriptionExpiry: firebase.firestore.Timestamp.fromDate(newExpiry),
            unlockedByAdmin: true,
            unlockedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        alert('‚úÖ Student account unlocked successfully!\n\n‚Ä¢ Subscription lock removed\n‚Ä¢ 30-day access granted\n‚Ä¢ Student can now access all features');
        
        // Reload the students list
        const listContainer = document.getElementById('admin-user-list-container');
        if (listContainer) {
            await loadAdminStudentsList(listContainer);
        }
        
    } catch (error) {
        console.error('Error unlocking student account:', error);
        alert('‚ùå Failed to unlock account: ' + error.message);
    }
}

async function lockStudentAccount(studentId) {
    if (!confirm('Are you sure you want to lock this student account?\n\nThis will:\nüîí Show subscription modal blocking all features\nüîí Set subscription as expired\nüîí Require payment to unlock\n\nThe student will NOT be able to access any features until unlocked.')) {
        return;
    }
    
    try {
        // Set subscription to expired (yesterday)
        const expiredDate = new Date();
        expiredDate.setDate(expiredDate.getDate() - 1);
        
        await db.collection('users').doc(studentId).update({
            subscriptionLocked: true,
            subscriptionExpiry: firebase.firestore.Timestamp.fromDate(expiredDate),
            lockedByAdmin: true,
            lockedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        alert('‚úÖ Student account locked successfully!\n\n‚Ä¢ Subscription modal will appear on login\n‚Ä¢ All features blocked\n‚Ä¢ Student must pay or contact admin to unlock');
        
        // Reload the students list
        const listContainer = document.getElementById('admin-user-list-container');
        if (listContainer) {
            await loadAdminStudentsList(listContainer);
        }
        
    } catch (error) {
        console.error('Error locking student account:', error);
        alert('‚ùå Failed to lock account: ' + error.message);
    }
}

async function deleteStudentAccount(studentId, studentName) {
    const confirmDelete = confirm(`‚ö†Ô∏è WARNING: Are you sure you want to permanently delete the account for "${studentName}"?\n\nThis will:\n- Delete their user account\n- Delete all their progress data\n- Remove them from their coach's student list\n\nThis action CANNOT be undone!`);
    
    if (!confirmDelete) {
        return;
    }
    
    const doubleConfirm = confirm(`Final confirmation: This will permanently delete all data for "${studentName}". Continue?`);
    
    if (!doubleConfirm) {
        return;
    }
    
    try {
        // Delete user document
        await db.collection('users').doc(studentId).delete();
        
        alert('‚úÖ Student account deleted successfully!');
        
        // Reload the students list
        const listContainer = document.getElementById('admin-user-list-container');
        if (listContainer) {
            await loadAdminStudentsList(listContainer);
        }
        
    } catch (error) {
        console.error('Error deleting student account:', error);
        alert('‚ùå Failed to delete account: ' + error.message);
    }
}

// ===== COACH ADMIN ACTIONS =====

async function viewCoachDetailsAdmin(coachId) {
    try {
        const coachDoc = await db.collection('users').doc(coachId).get();
        
        if (!coachDoc.exists) {
            alert('‚ùå Coach not found');
            return;
        }
        
        const coach = coachDoc.data();
        
        // Get coach's students
        const studentsSnapshot = await db.collection('users')
            .where('coachId', '==', coachId)
            .get();
        
        const students = [];
        studentsSnapshot.forEach(doc => {
            students.push({ id: doc.id, ...doc.data() });
        });
        
        const modal = document.createElement('div');
        modal.className = 'auth-modal active';
        modal.style.display = 'block';
        
        modal.innerHTML = `
            <div class="auth-content" style="max-width: 700px;">
                <div class="auth-header" style="background: linear-gradient(135deg, #667eea, #764ba2);">
                    <h2 style="color: white;">üë®‚Äçüè´ Coach Details</h2>
                    <button class="modal-close" onclick="this.closest('.auth-modal').remove()" style="color: white;">√ó</button>
                </div>
                <div class="auth-body">
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #0d3b66; margin-bottom: 15px;">üìã Basic Information</h3>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                            <p><strong>Name:</strong> ${coach.name || coach.firstName || 'N/A'} ${coach.lastName || ''}</p>
                            <p><strong>Email:</strong> ${coach.email || 'N/A'}</p>
                            <p><strong>User ID:</strong> ${coachId}</p>
                            <p><strong>Account Created:</strong> ${coach.createdAt ? new Date(coach.createdAt.toDate()).toLocaleDateString() : 'N/A'}</p>
                            <p><strong>Account Status:</strong> ${coach.subscriptionLocked ? 'üîí Locked' : '‚úÖ Active'}</p>
                            <p><strong>Total Students:</strong> ${students.length}</p>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #0d3b66; margin-bottom: 15px;">üë• Students (${students.length})</h3>
                        ${students.length === 0 ? 
                            '<p style="color: #666;">No students assigned to this coach.</p>' :
                            `<div style="background: #f8f9fa; padding: 15px; border-radius: 10px; max-height: 200px; overflow-y: auto;">
                                ${students.map(student => `
                                    <div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 5px;">
                                        <strong>${student.name || student.firstName || 'N/A'} ${student.lastName || ''}</strong>
                                        <br>
                                        <small style="color: #666;">${student.email || 'No email'}</small>
                                    </div>
                                `).join('')}
                            </div>`
                        }
                    </div>
                    
                    <button class="auth-submit" onclick="this.closest('.auth-modal').remove()">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
    } catch (error) {
        console.error('Error viewing coach details:', error);
        alert('‚ùå Failed to load coach details: ' + error.message);
    }
}

async function unlockCoachAccount(coachId) {
    if (!confirm('Are you sure you want to unlock this coach account?\n\nThis will grant full access to their dashboard.')) {
        return;
    }
    
    try {
        await db.collection('users').doc(coachId).update({
            subscriptionLocked: false,
            unlockedByAdmin: true,
            unlockedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        alert('‚úÖ Coach account unlocked successfully!');
        
        // Reload the coaches list
        const listContainer = document.getElementById('admin-user-list-container');
        if (listContainer) {
            await loadAdminCoachesList(listContainer);
        }
        
    } catch (error) {
        console.error('Error unlocking coach account:', error);
        alert('‚ùå Failed to unlock account: ' + error.message);
    }
}

async function lockCoachAccount(coachId) {
    if (!confirm('Are you sure you want to lock this coach account?\n\nThey will not be able to access their dashboard until unlocked.')) {
        return;
    }
    
    try {
        await db.collection('users').doc(coachId).update({
            subscriptionLocked: true,
            lockedByAdmin: true,
            lockedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        alert('‚úÖ Coach account locked successfully!');
        
        // Reload the coaches list
        const listContainer = document.getElementById('admin-user-list-container');
        if (listContainer) {
            await loadAdminCoachesList(listContainer);
        }
        
    } catch (error) {
        console.error('Error locking coach account:', error);
        alert('‚ùå Failed to lock account: ' + error.message);
    }
}

async function deleteCoachAccount(coachId, coachName) {
    const confirmDelete = confirm(`‚ö†Ô∏è WARNING: Are you sure you want to permanently delete the account for coach "${coachName}"?\n\nThis will:\n- Delete their coach account\n- Unassign all their students\n- Delete all their data\n\nThis action CANNOT be undone!`);
    
    if (!confirmDelete) {
        return;
    }

    const doubleConfirm = confirm(`Final confirmation: This will also unassign all students from this coach. Continue?`);

    if (!doubleConfirm) {
        return;
    }

    try {
        // First, unassign all students
        const studentsSnapshot = await db.collection('users')
            .where('coachId', '==', coachId)
            .get();
        
        const batch = db.batch();
        studentsSnapshot.forEach(doc => {
            batch.update(doc.ref, { coachId: null });
        });
        
        // Delete coach document
        batch.delete(db.collection('users').doc(coachId));
        
        await batch.commit();
        
        alert('‚úÖ Coach account deleted successfully and students unassigned!');
        
        // Reload the coaches list
        const listContainer = document.getElementById('admin-user-list-container');
        if (listContainer) {
            await loadAdminCoachesList(listContainer);
        }
        
    } catch (error) {
        console.error('Error deleting coach account:', error);
        alert('‚ùå Failed to delete account: ' + error.message);
    }
}

// ===== TOURNAMENT MODAL FUNCTIONS =====
function showCreateTournamentModal() {
    const modal = document.createElement('div');
    modal.className = 'auth-modal';
    modal.id = 'createTournamentModal';
    modal.style.display = 'block';
    modal.classList.add('active');
    modal.innerHTML = `
        <div class="auth-content" style="max-width: 600px;">
            <div class="auth-header" style="background: linear-gradient(135deg, #667eea, #764ba2);">
                <h2 style="color: white;">‚ûï Create New Tournament</h2>
                <button class="modal-close" onclick="closeCreateTournamentModal()" style="color: white;">√ó</button>
            </div>
            <div class="auth-body">
                <form id="create-tournament-form" onsubmit="handleCreateTournament(event)">
                    <div class="form-group">
                        <label>Tournament Name *</label>
                        <input type="text" id="tournament-name" required placeholder="e.g., Summer Spelling Championship 2025">
                    </div>
                    
                    <div class="form-group">
                        <label>Description *</label>
                        <textarea id="tournament-description" required rows="3" style="width: 100%; padding: 12px; border: 2px solid #0d3b66; border-radius: 5px; font-family: Georgia, serif; font-size: 1rem;" placeholder="Describe the tournament..."></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>Difficulty Level *</label>
                        <select id="tournament-level" required style="width: 100%; padding: 12px; border: 2px solid #0d3b66; border-radius: 5px; font-size: 1rem;">
                            <option value="">Select level</option>
                            <option value="foundation">üå± Foundation</option>
                            <option value="challenge">üéØ Challenge</option>
                            <option value="advanced">üöÄ Advanced</option>
                            <option value="championship">üèÜ Championship</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Start Date *</label>
                        <input type="date" id="tournament-date" required style="width: 100%; padding: 12px; border: 2px solid #0d3b66; border-radius: 5px; font-size: 1rem;">
                    </div>
                    
                    <div class="form-group">
                        <label>Start Time *</label>
                        <input type="time" id="tournament-time" required style="width: 100%; padding: 12px; border: 2px solid #0d3b66; border-radius: 5px; font-size: 1rem;">
                    </div>
                    
                    <div class="form-group">
                        <label>Max Participants</label>
                        <input type="number" id="tournament-max-participants" min="10" max="100" value="50" style="width: 100%; padding: 12px; border: 2px solid #0d3b66; border-radius: 5px; font-size: 1rem;">
                    </div>
                    
                    <div class="form-group">
                        <label>Status *</label>
                        <select id="tournament-status" required style="width: 100%; padding: 12px; border: 2px solid #0d3b66; border-radius: 5px; font-size: 1rem;">
                            <option value="upcoming">üìÖ Upcoming (Open for Registration)</option>
                            <option value="active">‚ñ∂Ô∏è Active (In Progress)</option>
                            <option value="completed">‚úÖ Completed</option>
                            <option value="cancelled">‚ùå Cancelled</option>
                        </select>
                    </div>
                    
                    <button type="submit" class="auth-submit" style="background: linear-gradient(135deg, #667eea, #764ba2);">
                        ‚úÖ Create Tournament
                    </button>
                    
                    <div id="create-tournament-error" class="feedback error" style="display: none; margin-top: 15px;"></div>
                </form>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
}

function closeCreateTournamentModal() {
    const modal = document.getElementById('createTournamentModal');
    if (modal) {
        modal.remove();
    }
}

async function handleCreateTournament(event) {
    event.preventDefault();
    
    if (!isAdmin) {
        alert('‚ùå Admin access required');
        return;
    }

    const name = document.getElementById('tournament-name').value.trim();
    const description = document.getElementById('tournament-description').value.trim();
    const level = document.getElementById('tournament-level').value;
    const date = document.getElementById('tournament-date').value;
    const time = document.getElementById('tournament-time').value;
    const maxParticipants = parseInt(document.getElementById('tournament-max-participants').value);
    const status = document.getElementById('tournament-status').value;

    const errorDiv = document.getElementById('create-tournament-error');

    try {
        console.log('üìù Creating tournament:', name);
        
        // Create tournament in Firestore
        const tournamentRef = await db.collection('tournaments').add({
            name: name,
            description: description,
            level: level,
            startDate: date,
            startTime: time,
            maxParticipants: maxParticipants,
            status: status,
            participants: 0,
            registeredUsers: [],
            createdBy: currentUser.uid,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        console.log('‚úÖ Tournament created:', tournamentRef.id);
        
        closeCreateTournamentModal();
        
        alert('‚úÖ Tournament created successfully!');
        
        // Reload admin panel tournaments section
        const contentContainer = document.getElementById('admin-content-container');
        if (contentContainer) {
            await loadAdminTournaments(contentContainer);
        }
        
        // Also reload tournament list if we're on tournaments page
        const tournamentsSection = document.getElementById('tournaments-section');
        if (tournamentsSection && tournamentsSection.classList.contains('active')) {
            await loadTournamentList();
        }
        
    } catch (error) {
        console.error('‚ùå Error creating tournament:', error);
        errorDiv.textContent = 'Failed to create tournament: ' + error.message;
        errorDiv.style.display = 'block';
    }
}
    </script>
</body>
</html>

